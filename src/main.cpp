#include <Arduino.h>
// Version 3.0 - Dual Shift Support with Named Shifts

#include <Wire.h>
#include <Adafruit_GFX.h>
#define SSD1306_NO_SPLASH 1
#include <Adafruit_SSD1306.h>



#if defined(ESP8266)
  #define OLED_SDA 4
  #define OLED_SCL 5
  #include <ESP8266WiFi.h>
#elif defined(ESP32)
  #include <WiFi.h>
  #include "BluetoothSerial.h"
  BluetoothSerial SerialBT;
  // For LOLIN32 Lite
  // #define OLED_SDA 25
  // #define OLED_SCL 26

  // For Stardard ESP32 boards
  #define OLED_SDA 21
  #define OLED_SCL 22
  
#else
  #error "Unsupported board"
#endif

#include <PubSubClient.h>

// WiFiClient espClient;  // ✅ Declare once globally
// PubSubClient mqttClient(espClient);  // Use it for MQTT, etc.

#include <RTClib.h>   // for DateTime
#include "time.h"
// char ntpServer[32] = "pool.ntp.org";//"bdc-lcb1.lcb1.com";//

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);


// Ensure pin is ordered correctly for the board
// Standard board
// #define ENGINE_INPUT_PIN 12
// #define MOVE_INPUT_PIN 14
// #define CHECK_ENGINE_INPUT_PIN 27

// ESP32 D1 mini
#define ENGINE_INPUT_PIN 16
#define MOVE_INPUT_PIN 17
#define CHECK_ENGINE_INPUT_PIN 27

#define LED_PIN 25
#define MAX_SERVER_LEN       32


#define LED_FLASH_DURATION 200  // milliseconds
bool flashActive = false;
unsigned long flashStartTime = 0;
// End move

const int EEPROM_ADDR_INTERVAL = 51;


const unsigned long DISPLAY_UPDATE_INTERVAL = 1000;

// String engine_name = "";
bool engineRunning = false;
unsigned long engineStartTime = 0;
unsigned long lastSaveTime = 0;
unsigned long lastDisplayUpdate = 0;
// float totalEngineHours = 0;


bool wasEngineRunning = false;

int lastShift1ResetDay = -1;
int lastShift2ResetDay = -1;


int lastShiftIndex = -1;

unsigned long lastMQTTSendTime = 0;
unsigned long mqttSendInterval = 5*60*1000; // default 5 minutes
// End MTTQ

bool alertDisplay = false; //Show Normal mode(Engine hour) or Alert mode (check engine,Batt,PM)
int engine_check = 0; //IN case found Check Engine alram set to 1

String alertMsg = "";
bool isPm = false;
bool isCheckEngine = false;
bool isChargeFail = false;
bool isLifting = false;

// Constants
#define EEPROM_MIN_ACTIVE_ADDR 300  // Choose an unused EEPROM address
#define DEBOUNCE_DELAY_MS 50     // Debounce time
#define MIN_ACTIVE_MS 10000        // Minimum time the input must stay HIGH to count (configurable)

// State variables
unsigned int minActiveMs = 10000;         // Default value 10 Sec
bool moveButtonState = LOW;             // Current stable state
bool lastMoveButtonState = LOW;         // Previous raw reading
unsigned long lastDebounceTime = 0;     // For debouncing
unsigned long highStartTime = 0;        // When HIGH state started
bool highStable = false;                // Track if HIGH was stable long enough


// Added on May 20,2025 -- To fix large number of Hour (long)
#define EEPROM_ADDR_TOTAL_MINUTES 310  // Use 4 bytes for unsigned long
unsigned long totalEngineMinutes = 0; // stores total runtime in minutes
unsigned long lastMinuteUpdate = 0;

// Wifi re-connect variable
unsigned long wifi_previousMillis = 0;
unsigned long wifi_interval = 30000;


// Buzzser
#define BUZZER_PIN 13  // or any suitable GPIO
unsigned long lastBuzzerToggle = 0;
bool buzzerLogicState = true; // start HIGH (silent for active-LOW)

// NTP server
#define NTP_ADDR 320 //Keep NTP server

// To show INPUT change state
bool lastStateMove = LOW;
bool lastStateCheckEngine = LOW;

// Running indecator
unsigned long lastRunningBlinkTime = 0;
bool runningBlinkState = false;
const int RUNNING_BLINK_INTERVAL = 500; // ms

// Reconnect MQTT
unsigned long lastMQTTAttempt = 0;
const long mqttRetryInterval = 10000; // 10 seconds
bool mqttConnected = false;

// Define your DateTime variable
struct MyDateTime {
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int second;
};

MyDateTime currentTime;

unsigned long lastNtpAttempt = 0;
bool ntpSynced = false;

char ssid[32], pass[32];

bool resyncDoneMorning = false;
bool resyncDoneEvening = false;

// Added on July 29,2025 -- To save last sent MQTT data
float lastSentHour = -1.0;
int lastSentMove = -1;
int lastSentCheckEngine = -1;
float lastSentBattery = -1.0;

unsigned long lastSentEngineMinutes = 0;  // To track last sent time

#include "esp_bt_device.h"
#include "esp_bt_main.h"




// Alert image
const uint8_t image_check_engine[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x7f, 0x87, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0xe4, 0x9e, 0x72, 0x41, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x24, 0x90, 0x9a, 0x81, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x07, 0x9c, 0x83, 0x81, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0x07, 0x9c, 0x83, 0x81, 0xfc, 0x18, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0x24, 0x90, 0x9a, 0x40, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0xe4, 0x9e, 0x72, 0x60, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xe9, 0x19, 0x41, 0xc0, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x09, 0x65, 0x61, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xcd, 0x41, 0x71, 0xc0, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x0b, 0x4d, 0x59, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x0b, 0x65, 0x49, 0x00, 0xfc, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xe9, 0x39, 0x49, 0xe1, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xce, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x01, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x01, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};



const uint8_t image_oil_change[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x03, 0x80, 0x00, 0x07, 0xff, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x79, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xfe, 0x08, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x78, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0x1c, 0x00, 0x00, 0x1f, 0xe3, 0xe0, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3e, 0x1c, 0x00, 0x00, 0x0f, 0x07, 0xc0, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1e, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0f, 0x1c, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0xdc, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// const GFXglyph customGlyph = { image_data, 128, 64, 128, 0, 0 };
// const GFXfont customFont = { (uint8_t *)image_data, &#038;customGlyph, 32, 127, 64 };

// const uint8_t image_battery[] PROGMEM = {
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x07, 0xf0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0c, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0c, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x18, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x18, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x7c, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0xfc, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0x0c, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0x18, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x3f, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0xc0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// };

// const uint8_t image_clock_error[] PROGMEM = {
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x3f, 0xfe, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x03, 0xff, 0xff, 0xc0, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x0f, 0xff, 0xff, 0xf8, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x3f, 0xff, 0xff, 0xfc, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xff, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0xff, 0x80, 0x01, 0xff, 0x83, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0x83, 0xfe, 0x00, 0x00, 0x3f, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x1f, 0x07, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0xf8, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0xe0, 0x00, 0x00, 0x03, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x06, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfc, 0x60, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x01, 0x80, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x01, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x01, 0x80, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x01, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x01, 0x80, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x01, 0x80, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x01, 0x80, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xfe, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe7, 0xff, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0xff, 0xff, 0x81, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x0f, 0xf8, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
// };

const uint8_t image_move_up[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x91, 0x11, 0x11, 0x08, 0x88, 0x8b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x91, 0x10, 0x00, 0x00, 0x00, 0x8b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t image_company[] PROGMEM = {
0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x3f, 0xc0, 0x03, 0xf9, 0xff, 0x80, 0xff, 0xff, 0xff, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x3f, 0xc0, 0x0f, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3f, 0xc0, 0x3f, 0xff, 0xff, 0x81, 0xff, 0xff, 0xfe, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x1f, 0x00, 0x7f, 0x9f, 0xbf, 0xc1, 0xff, 0xe7, 0xce, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3b, 0x83, 0xbc, 0xc7, 0x86, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf8, 0x07, 0x7f, 0xc7, 0xfd, 0xc7, 0x8e, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf0, 0x00, 0x33, 0xc7, 0x3c, 0x0f, 0x80, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf0, 0x00, 0x73, 0xcf, 0x7c, 0x0f, 0x80, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3c, 0x01, 0xe0, 0x00, 0x73, 0xce, 0x78, 0x0f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x7c, 0x1f, 0xe0, 0x00, 0x73, 0xfe, 0x78, 0x1f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3f, 0xf0, 0x00, 0xf3, 0xfc, 0xf8, 0x1f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3f, 0xf0, 0x08, 0xe3, 0xf8, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3d, 0xf0, 0x1e, 0xe3, 0xf8, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x7c, 0x3d, 0xf8, 0x7f, 0xe1, 0xf0, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x01, 0xff, 0xf8, 0xff, 0xff, 0xf1, 0xe3, 0xfc, 0x7f, 0x80, 
0x00, 0x7f, 0xc0, 0x01, 0xfe, 0x00, 0x01, 0xff, 0xf8, 0x7f, 0xf7, 0xf1, 0xe7, 0xfc, 0xff, 0x80, 
0x00, 0x3f, 0xc0, 0x01, 0xfe, 0x00, 0x03, 0xff, 0xf8, 0x1f, 0xc7, 0xf1, 0xc7, 0xf8, 0xff, 0x80, 
0x00, 0x3f, 0xc0, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x1f, 0xc0, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xa9, 0x44, 0x00, 0x10, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xdf, 0xe0, 0xff, 0xff, 0x6b, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xdb, 0xe0, 0xdf, 0xf6, 0xeb, 0xfb, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xe0, 0xff, 0xf6, 0xfa, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xfd, 0xb0, 0xc6, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0xff, 0xff, 0xf0, 0x46, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0xff, 0xff, 0xfc, 0x47, 0xef, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t wifi_icon[] PROGMEM = {
0x07, 0xe0, 
0x1f, 0xf8, 
0x38, 0x1c, 
0x60, 0x06, 
0xc7, 0xe3, 
0x1c, 0x38, 
0x18, 0x18, 
0x13, 0xc8, 
0x07, 0xe0, 
0x04, 0x20, 
0x01, 0x80, 
0x01, 0x80, 
0x00, 0x00, 
0x00, 0x00, 
0x00, 0x00, 
0x00, 0x00, 
};

const uint8_t chain_icon[] PROGMEM = {
0x00, 0x00, 
0x06, 0x80, 
0x0c, 0x00, 
0x00, 0x80, 
0x35, 0x80, 
0x6b, 0x00, 
0x40, 0x00, 
0x08, 0x00, 
0x58, 0x00, 
0x00, 0x00, 
};


#include <Preferences.h>
Preferences prefs;

Preferences prefMqtt;
#define PREFNS "mqttprefs"

// Added on Oct 10,2025 -- To disable WIFI power
#include "esp_wifi.h"

  String engine_name = "";
  float totalEngineHours = 0.0;
  float totalEngineMins = 0.0;
  uint32_t totalMoves = 0;


  char engineName[32] = "Engine-X";
  char mqttServer[32] = "192.168.1.100:1883";

  WiFiClient espClient;
  PubSubClient mqttClient(espClient);
  char mqttHost[64] = "";
  uint16_t mqttPort = 1883;
  char mqttUser[32] = "";
  char mqttPass[32] = "";

  unsigned long mqttLastConnectAttempt = 0;
  const unsigned long mqttReconnectInterval = 10000; // try every 10 sec

  // for saving engine hours
  unsigned long SAVE_INTERVAL = 60 * 1000UL;
  unsigned long lastSaveMillis = 0;

  bool btEnable = false;

// Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
// uint32_t lastNtpSyncEpoch = 0;
time_t lastNtpSyncEpoch = 0;
bool ntpAvailable = false;
const unsigned long MAX_NTP_AGE_SEC = 24UL * 3600UL;  // 1 day


// Added on Oct 11,2025 -- To support Volt meter
// Calibration structure  
// #include <EEPROM.h>

#define ADC_PIN 34  // GPIO34 (ADC1_CH6) on ESP32
#include "esp_adc_cal.h"
#define voltage_divider_offset 1 //2.174 // Should be a value of 2.000, but ADC input impedance loads the voltage divider, req

// Global variables for resistor values
// float R1_value = 100000.0; // 100k ohms
// float R2_value = 10000.0;  // 10k ohms

float R1 = 150000.0;  // 150k ohms
float R2 = 10000.0;   // 10k ohms
float DIVIDER_RATIO = (R1 + R2) / R2; // 16:1

// Calibration values
float vref_actual = 3.300;    // MEASURE this with multimeter!
float adc_calibration = 1.0;  // ADC linearity correction
float voltage_offset = 0.0;   // Zero offset correction
float voltage1 = 21.0;       // First calibration point voltage
float reading1 = 21.0;       // First calibration point reading 
float voltage2 = 29.0;       // Second calibration point voltage
float reading2 = 29.0;       // Second calibration point reading
float slope = 1.0;           // Calculated slope
float offset = 0.0;          // Calculated offset 

struct CalibrationData {
  float slope;
  float offset;
  uint32_t checksum;
};

CalibrationData calData;


// struct ResistorData {
//     float R1;
//     float R2;
//     uint32_t checksum;
// };

// ResistorData resistorData;

// uint32_t calculateResistorChecksum();

// uint32_t calculateResistorChecksum() {
//     return (uint32_t)(R1_value * 0.001) ^ (uint32_t)(R2_value * 0.001) ^ 0x1234ABCD;
// }

void loadCalibration() {
  prefs.begin("voltmeter", true);
  vref_actual = prefs.getFloat("vref", 3.300);
  adc_calibration = prefs.getFloat("adc_cal", 1.0);
  voltage_offset = prefs.getFloat("v_offset", 0.0);
  voltage1 = prefs.getFloat("voltage1", 21.0);
  reading1 = prefs.getFloat("reading1", 21.0);
  voltage2 = prefs.getFloat("voltage2", 29.0);
  reading2 = prefs.getFloat("reading2", 29.0);
  R1 = prefs.getFloat("R1", 150000);
  R2 = prefs.getFloat("R2", 10000);
  prefs.end();
}
void saveCalibration() {
  prefs.begin("voltmeter", false);
  prefs.putFloat("vref", vref_actual);
  prefs.putFloat("adc_cal", adc_calibration);
  prefs.putFloat("v_offset", voltage_offset);
  prefs.putFloat("voltage1", voltage1);
  prefs.putFloat("reading1", reading1);
  prefs.putFloat("voltage2", voltage2);
  prefs.putFloat("reading2", reading2);
  prefs.putFloat("R1", R1);
  prefs.putFloat("R2", R2);
  DIVIDER_RATIO = (R1 + R2) / R2; // 16:1
  prefs.end();
}

float readPreciseVoltage() {
  // Take multiple samples with oversampling
  long total = 0;
  const int samples = 64;
  
  for (int i = 0; i < samples; i++) {
    total += analogRead(ADC_PIN);
    delayMicroseconds(100); // Spread out samples
  }
  
  float averageADC = (total / (float)samples) * adc_calibration;
  if (averageADC > 4095) averageADC = 4095;
  
  // Calculate voltage with high precision
  float adcVoltage = (averageADC * vref_actual) / 4095.0;
  float inputVoltage = (adcVoltage * DIVIDER_RATIO) + voltage_offset;
  
  return inputVoltage;
}

void measureReferenceVoltage(Stream &src,float volt_ref) {
  src.println("\n=== MEASURE REFERENCE VOLTAGE ===");
  src.println("CRITICAL FOR ACCURACY!");
  src.println("");
  src.println("1. Use multimeter on ESP32 3.3V pin");
  src.println("2. Measure between 3.3V and GND pins");
  src.println("3. Enter EXACT voltage (e.g., 3.28, 3.30, 3.32):");
  
  float measured = volt_ref;
  if (measured >= 3.20 && measured <= 3.40) {
    vref_actual = measured;
    saveCalibration();
    src.printf("✓ Reference voltage set to: %.3fV\n", vref_actual);
    src.println("This improves accuracy by 2-5%!");
  } else {
    src.println("❌ Invalid voltage (should be ~3.3V)");
  }
}

void lowPointCalibration(Stream &src,float target_volt)   {
  src.println("\n=== LOW-POINT CALIBRATION ===");
  src.println("For improved accuracy");
  src.println("");
  
  // Point 1: Low voltage (20-22V)
  src.printf("STEP 1: Apply ~%.2fV (e.g., %.2fV)\n", target_volt, target_volt);
  src.println("Enter EXACT voltage from calibrated source:");
  float voltage1 = target_volt;
  
  if (voltage1 < 20 || voltage1 > 22) {
    src.println("❌ Please use 20-22V range");
    return;
  }
  src.println("Measuring... (32 samples)");
  voltage1 = target_volt;
  reading1 = readPreciseVoltage();
  src.printf("Device reads: %.2fV (should be: %.2fV)\n", reading1, voltage1);
  saveCalibration();
  
  src.println("\n✓ LOW-POINT CALIBRATION COMPLETE");
  src.printf("Reading: %.2fV\n", reading1);
  src.printf("Set low-point voltage to: %.2fV\n", voltage1);

}

void highPointCalibration(Stream &src,float target_volt){
  src.println("\n=== HIGH-POINT CALIBRATION ===");
  src.println("For improved accuracy");
  src.println("");
  
  // Point 2: High voltage (28-30V)
  src.printf("STEP 2: Apply ~%.2fV (e.g., %.2fV)\n", target_volt, target_volt);
  src.println("Enter EXACT voltage from calibrated source:");
  float voltage2 = target_volt;
  
  if (voltage2 < 28 || voltage2 > 30) {
    src.println("❌ Please use 28-30V range");
    return;
  }
  
  src.println("Measuring... (32 samples)");
  voltage2 = target_volt;
  reading2 = readPreciseVoltage();
  src.printf("Device reads: %.2fV (should be: %.2fV)\n", reading2, voltage2);
  
  saveCalibration();
  
  src.println("\n✓ HIGH-POINT CALIBRATION COMPLETE");
  src.printf("Reading: %.2fV\n", reading2);
  src.printf("Set high-point voltage to: %.2fV\n", voltage2);
}

void calculateCalibration(Stream &src) {
  src.println("\n=== CALCULATE CALIBRATION PARAMETERS ===");
  src.println("Using previously saved low and high points");
  
  if (reading1 == reading2) {
    src.println("❌ Error: Low and high readings are the same.");
    return;
  }
  
  // Calculate calibration parameters
  // Using linear regression: V_actual = slope * V_measured + offset
  slope = (voltage2 - voltage1) / (reading2 - reading1);
  offset = voltage1 - (reading1 * slope);
  
  adc_calibration = slope;
  voltage_offset = offset;
  
  saveCalibration();
  
  src.println("\n✓ CALIBRATION PARAMETERS UPDATED");
  src.printf("Slope: %.4f\n", adc_calibration);
  src.printf("Offset: %.3fV\n", voltage_offset);
  
  // Verify
  src.println("Verification:");
  float test1 = (reading1 * adc_calibration) + voltage_offset;
  float test2 = (reading2 * adc_calibration) + voltage_offset;
  src.printf("Low point: %.2fV → %.2fV\n", reading1, test1);
  src.printf("High point: %.2fV → %.2fV\n", reading2, test2);
}

void showAccuracyInfo(Stream &src) {
  src.println("\n=== ACCURACY INFORMATION ===");
  src.printf("Hardware: R1=%.0fΩ, R2=%.0fΩ\n", R1, R2);
  src.printf("Divider Ratio: %.1f:1\n", DIVIDER_RATIO);
  src.printf("Reference Voltage: %.3fV ", vref_actual);
  if (vref_actual == 3.300) {
    src.println("(ASSUMED - run MEASURE_REF)");
  } else {
    src.println("(MEASURED)");
  }
  src.printf("ADC Calibration: %.4f\n", adc_calibration);
  src.printf("Voltage Offset: %.3fV\n", voltage_offset);
  
  // Current performance
  float voltage = readPreciseVoltage();
  src.printf("\nCurrent Reading: %.2fV\n", voltage);
  
  if (vref_actual == 3.300) {
    src.println("⚠️  Accuracy: ±2% (run MEASURE_REF to improve)");
  } else if (adc_calibration == 1.0 && voltage_offset == 0.0) {
    src.println("⚠️  Accuracy: ±1% (run TWO_POINT_CAL to improve)");
  } else {
    src.println("✅ Accuracy: ±0.5% (high accuracy mode)");
  }
}

void showHardwareInfo() {
  SerialBT.println("\n=== HARDWARE CONFIGURATION ===");
  SerialBT.println("Board: ESP32 D1 Mini");
  SerialBT.println("ADC Pin: GPIO35");
  SerialBT.printf("Resistors: R1=150kΩ, R2=10kΩ\n");
  SerialBT.printf("Voltage Range: 0-48V (Safe: 20-30V)\n");
  SerialBT.printf("ADC Resolution: %.2fmV/bit\n", (30.0 / DIVIDER_RATIO) / 4095 * 1000);
  SerialBT.println("Wiring: 30V → 150k → 10k → GND");
  SerialBT.println("        ESP32 GPIO35 → between 150k & 10k");
}


// void saveResistorValues(Stream &src) {
//   prefs.begin("voltmeter", false);
    
//     prefs.putFloat("R1", R1_value);
//     prefs.putFloat("R2", R2_value);
    
//     prefs.end();
    
//     src.println("✓ Resistor values saved to Preferences");
//     src.printf("R1=%.0fΩ, R2=%.0fΩ\n", R1_value, R2_value);
// }

// void loadResistorValues(Stream &src) {

//     prefs.begin("voltmeter", false); // false for read/write mode
    
//     // Load values, use defaults if not found
//     R1_value = prefs.getFloat("R1", 100000.0);
//     R2_value = prefs.getFloat("R2", 10000.0);
    
//     src.printf("Loaded resistors: R1=%.0fΩ, R2=%.0fΩ\n", R1_value, R2_value);
    
//     prefs.end();
// }


// float ReadVoltage(byte ADC_Pin) {
//   float calibration  = 1.000; // Adjust for ultimate accuracy when input is measured using an accurate DVM, if reading too high then use e.g. 0.99, too low use 1.01
//   float vref = 1100;
//   esp_adc_cal_characteristics_t adc_chars;
//   esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, 1100, &adc_chars);
//   vref = adc_chars.vref; // Obtain the device ADC reference voltage
//   return (analogRead(ADC_Pin) / 4095.0) * 3.3 * voltage_divider_offset * (1100 / vref) * calibration;  // ESP by design reference voltage in mV
// }

// float readVoltageWithResistors() {
//     // int rawADC = analogRead(ADC_PIN);
//     // float vOut = (rawADC * 3.3) / 4095.0;
//      float vOut = (ReadVoltage(ADC_PIN)+ 0.5867) / 0.10875;
//     // Pure voltage divider calculation
//     // Vin = Vout * (R1 + R2) / R2
//     // float vIn = vOut * ((R1_value + R2_value) / R2_value);
//     float vIn = vOut;
//     return vIn;
// }
void showResistorStatus(Stream &src) {
    src.println("=== RESISTOR STATUS ===");
    src.printf("R1: %.0f ohms\n", R1);
    src.printf("R2: %.0f ohms\n", R2);
    src.printf("Divider Ratio: %.3f\n", (R1 + R2) / R2);
    src.printf("Max Input Voltage: %.1fV\n", vref_actual * ((R1 + R2) / R2));
    // src.printf("Current Reading: %.2fV\n", readVoltageWithResistors());
}
// void testAccuracy(Stream &src) {
//     src.println("=== ACCURACY TEST ===");
//     src.println("Apply known voltages and compare:");
//     src.println("Expected vs Measured should be very close!");
    
//     for (int i = 0; i < 5; i++) {
//         float voltage = readVoltageWithResistors();
//         src.printf("Reading %d: %.2fV\n", i+1, voltage);
//         delay(2000);
//     }
// }
// void showResistorHelp(Stream &src) {
//     src.println("=== RESISTOR COMMANDS ===");
//     src.println("SET_RESISTORS     - Set R1 and R2 values");
//     src.println("R:100000,10000    - Quick set resistors");
//     src.println("MEASURE_RESISTORS - Guide to measure actual resistors");
//     src.println("RESISTOR_STATUS   - Show current resistor values");
//     src.println("TEST_ACCURACY     - Test voltage reading accuracy");
//     src.println("HELP              - This help message");
// }

// float readRawVoltage() {
//   int rawADC = analogRead(ADC_PIN);
//   float vOut = (rawADC * 3.3) / 4095.0;
//   return vOut * 11.0; // Raw voltage without calibration
// }

// float readCalibratedVoltage() {
//   float rawVoltage = readRawVoltage();
//   return (rawVoltage * calData.slope) + calData.offset;
// }

// Single command: "R:100000,10000"
void setResistorsCommand(Stream &src,String command) {
    int commaPos = command.indexOf(',');
    if (commaPos > 0) {
        R1 = command.substring(2, commaPos).toFloat();
        R2 = command.substring(commaPos + 1).toFloat();
        
        if (R1 < 1000 || R1 > 1000000 || R2 < 1000 || R2 > 1000000) {
            src.println("✗ Resistor values out of range (1k-1M ohms)");
            return;
        }

        DIVIDER_RATIO = (R1 + R2) / R2;
        saveCalibration();
        src.printf("✓ Resistors set: R1=%.0fΩ, R2=%.0fΩ\n", R1, R2);
    }
}
// // Single command: "CAL:12.5,24.8,30.1"
// void oneCommandCalibration(String command,Stream &src) {
//     // Format: CAL:reading12v,reading24v,reading30v
//     // Example: CAL:11.8,23.6,29.5
//     int firstComma = command.indexOf(',');
//     int secondComma = command.lastIndexOf(',');
    
//     if (firstComma > 0 && secondComma > firstComma) {
//         float read12 = command.substring(4, firstComma).toFloat();
//         float read24 = command.substring(firstComma + 1, secondComma).toFloat();
//         float read30 = command.substring(secondComma + 1).toFloat();
        
//         // Calculate using 12V-24V pair
//         float slope1 = (24.0 - 12.0) / (read24 - read12);
//         float offset1 = 12.0 - (read12 * slope1);
        
//         // Calculate using 12V-30V pair  
//         float slope2 = (30.0 - 12.0) / (read30 - read12);
//         float offset2 = 12.0 - (read12 * slope2);
        
//         // Calculate using 24V-30V pair
//         float slope3 = (30.0 - 24.0) / (read30 - read24);
//         float offset3 = 24.0 - (read24 * slope3);
        
//         // Use averages
//         calData.slope = (slope1 + slope2 + slope3) / 3.0;
//         calData.offset = (offset1 + offset2 + offset3) / 3.0;
        
//         saveCalibration(src);
        
//         src.println("✓ SMART 3-POINT CALIBRATION DONE");
//         src.printf("Slope: %.3f\n", calData.slope);
//         src.printf("Offset: %.3f\n", calData.offset);
        
//         src.println("Verification (should be close to 12,24,30):");
//         src.printf("12V: %.2f -> %.2f\n", read12, (read12 * calData.slope) + calData.offset);
//         src.printf("24V: %.2f -> %.2f\n", read24, (read24 * calData.slope) + calData.offset);
//         src.printf("30V: %.2f -> %.2f\n", read30, (read30 * calData.slope) + calData.offset);
//     } else {
//         src.println("✗ Invalid CAL command format");
//     }
// }

// void startTwoPointCalibration(Stream &src) {
//   src.println("\n=== TWO-POINT CALIBRATION ===");
//   src.println("This will save calibration PERMANENTLY to EEPROM");
//   src.println("Values will survive power cycles and resets");
  
//   // Point 1: Low voltage
//   src.println("\nSTEP 1: Apply LOW known voltage (e.g., 12.00V)");
//   src.println("Wait for reading to stabilize, then enter actual voltage:");
  
//   while (!src.available());
//   float lowActual = src.parseFloat();
//   src.read(); // Clear newline
  
//   // Take multiple readings for stability
//   float lowReading = 0;
//   for (int i = 0; i < 10; i++) {
//     lowReading += readRawVoltage();
//     delay(200);
//     src.print(".");
//   }
//   lowReading /= 10;
//   src.printf("\nLow point: Actual=%.2fV, Reading=%.2fV\n", lowActual, lowReading);
  
//   // Point 2: High voltage  
//   src.println("\nSTEP 2: Apply HIGH known voltage (e.g., 24.00V)");
//   src.println("Wait for reading to stabilize, then enter actual voltage:");
  
//   while (!src.available());
//   float highActual = src.parseFloat();
//   src.read(); // Clear newline
  
//   float highReading = 0;
//   for (int i = 0; i < 10; i++) {
//     highReading += readRawVoltage();
//     delay(200);
//     src.print(".");
//   }
//   highReading /= 10;
//   src.printf("High point: Actual=%.2fV, Reading=%.2fV\n", highActual, highReading);
  
//   // Calculate new calibration parameters
//   calData.slope = (highActual - lowActual) / (highReading - lowReading);
//   calData.offset = lowActual - (lowReading * calData.slope);
  
//   // Save to EEPROM permanently
//   saveCalibration(src);
  
//   // Verification
//   src.println("\n=== CALIBRATION COMPLETE ===");
//   src.printf("New Slope: %.3f\n", calData.slope);
//   src.printf("New Offset: %.3f\n", calData.offset);
//   src.println("✓ Saved permanently to EEPROM");
  
//   src.println("\nVerification readings:");
//   for (int i = 0; i < 5; i++) {
//     float calibrated = readCalibratedVoltage();
//     src.printf("Reading %d: %.2fV\n", i+1, calibrated);
//     delay(1000);
//   }
// }
// Added on Oct 11,2025 -- To support Volt meter

// CALIBRATION VALUES FOR YOUR SPECIFIC DIVIDER
// const float CALIBRATION_SLOPE = 1.118f;    // Calculated slope
// const float CALIBRATION_OFFSET = 0.092f;   // Calculated offset
// const float VOLTAGE_DIVIDER_RATIO = 11.0;  // Keep theoretical ratio

// Range-specific calibration for 20V-30V
const float LOW_RANGE_SLOPE = 1.118f;     // Your current calibration
const float LOW_RANGE_OFFSET = 0.092f;

// Fine-tuned calibration for 20V-30V range
const float BATTERY_RANGE_SLOPE = 1.105f;   // Adjusted for 24V system
const float BATTERY_RANGE_OFFSET = 0.15f;   // Adjusted for 24V system
const float VOLTAGE_DIVIDER_RATIO = 11.0;  // Keep theoretical ratio

// Moving average settings
const int SAMPLE_SIZE = 20;      // Number of samples for averaging
float voltageReadings[SAMPLE_SIZE];
int readingIndex = 0;
float voltageSum = 0;
float lastValidVoltage = 0.0;
float lastSentVoltage = 0.0;

static unsigned long lastVoltageCheck = 0;

// float readStableVoltage() {

//   float baseVoltage  = readVoltageWithResistors();
//   voltageSum -= voltageReadings[readingIndex];
//   voltageReadings[readingIndex] = baseVoltage;
//   voltageSum += baseVoltage;
//   readingIndex = (readingIndex + 1) % SAMPLE_SIZE;
//     return voltageSum / SAMPLE_SIZE;
// }
// End Volt meter


// Added on July 29,2025 -- To show BT macid
void printBluetoothMAC(Stream &src) {
  const uint8_t* mac = esp_bt_dev_get_address();
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  src.println("Bluetooth MAC Address: " + String(macStr) + "\n");
}

  // To print out on both Serial and bluetooth
void printAll(const char *fmt, ...) {
    char buf[128];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);

    Serial.print(buf);
    if (btEnable && SerialBT.hasClient()) {
        SerialBT.print(buf);
    }
}


void printBoth(const String& msg) {
  Serial.print(msg);
  #if defined(ESP32)
  SerialBT.print(msg);
  #endif
}

void printlnBoth(const String& msg) {
  Serial.println(msg);
  #if defined(ESP32)
  SerialBT.println(msg);
  #endif
}
// Overide printlnBoth
void printlnBoth(const char* msg) {
  Serial.println(msg);
  #if defined(ESP32)
  SerialBT.println(msg);
  #endif
}

void mqttHostPort(){
  char *colon = strchr(mqttServer, ':');
  if (colon != NULL) {
      // Found ':'
      size_t ipLen = colon - mqttServer;
      strncpy(mqttHost, mqttServer, ipLen);
      mqttHost[ipLen] = '\0';  // Null terminate

      mqttPort = atoi(colon + 1);
  } else {
      // No ':', use full as host
      strncpy(mqttHost, mqttServer, sizeof(mqttHost));
      mqttHost[sizeof(mqttHost) - 1] = '\0';
      mqttPort = 1883;  // default
  }
}

// NTP server settings
#define MAX_NTP 5
char ntpList[MAX_NTP][32];
static unsigned long lastCheck = 0;

void syncNTP(Stream &src) {
    // Ensure Wiifi is connected
    if (!WiFi.isConnected()) {
        src.println("❌ WiFi not connected. Cannot sync NTP.");
        return;
    }
    time_t now = time(nullptr);
    // If time already synced (example > 2024)
    if (now > 1700000000) {  // ~Jan 2024 timestamp
        src.println("⏳ Already synced — skip resync.");
        return;
    }

    struct tm timeinfo;
    bool synced = false;

    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) == 0) continue;

        configTime(3600 * 7, 0, ntpList[i]); // Example +7 timezone
        delay(2000);  // wait for NTP

        if (getLocalTime(&timeinfo)) {
            src.printf("✅ NTP sync OK: %s\n", ntpList[i]);
            synced = true;
            ntpSynced = true;
            break;
        } else {
            src.printf("⚠️ NTP failed: %s\n", ntpList[i]);
        }
    }

    // Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
    if (synced) {
      time_t t = time(nullptr);  // current UNIX time (same as now.unixtime())
      lastNtpSyncEpoch = t;

      // Save to preferences
      prefs.begin("ntp", false);
      prefs.putULong("lastsync", lastNtpSyncEpoch);  // or putUInt if you're sure it fits
      prefs.end();

        // time_t t = static_cast<time_t>(lastNtpSyncEpoch);  // Convert to time_t
        src.printf("✅ NTP sync successful. Last sync: %s", ctime(&t));  // No newline needed

        // src.printf("✅ NTP sync successful. Last sync: %s\n", ctime(&lastNtpSyncEpoch));
        printAll("✅ NTP sync successful. Last sync: ");
    } else {
        ntpAvailable = false;
        printAll("❌ NTP sync failed.");
    }
    
}

void loadNTPSettings() {
    prefs.begin("engine-hour", true);
    prefs.getBytes("ntpList", ntpList, sizeof(ntpList));
    prefs.end();
}

void saveNTPSettings() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("ntpList", ntpList, sizeof(ntpList));
    prefs.end();
    Serial.println("💾 NTP settings saved!");
}



// void checkNtpStatus(Stream &out) {
//   uint32_t nowEpoch = millis() / 1000; // uptime in seconds

//   if (!ntpAvailable) {
//     out.println("⚠️  NTP not available. Using internal time.");
//   }

//   if (lastNtpSyncEpoch == 0) {
//     out.println("❌ No NTP sync history found.");
//     return;
//   }

//   uint32_t timeSinceSync = nowEpoch - (lastNtpSyncEpoch % 0xFFFFFFFF);
//   out.printf("🕒 Last NTP sync was %lu sec ago (%lu min)\n", timeSinceSync, timeSinceSync / 60);

//   if (timeSinceSync < 3600) {
//     out.println("✅ Time is accurate (synced < 1 hour ago).");
//   } else if (timeSinceSync < MAX_NTP_AGE_SEC) {
//     out.println("⚠️  Time may drift (last sync > 1 hour).");
//   } else {
//     out.println("❗ NTP sync too old (> 1 day) — risk of drift.");
//   }
// }
void checkNtpStatus(Stream &out) {
  time_t now = time(nullptr);
  if (now < 1000000000L) { // means not synced
    out.println("⚠️ System time not set yet!");
    return;
  }

  long diff = now - lastNtpSyncEpoch;

  if (diff < 0) {
    out.printf("⚠️ System clock is behind last NTP sync by %ld sec\n", -diff);
    return;
  }

  out.printf("🕒 Last NTP sync was %ld sec ago (%ld min)\n", diff, diff / 60);

  if (diff > 86400) {
    out.println("❗ NTP sync too old (> 1 day) — risk of drift.");
  } else {
    out.println("✅ NTP sync is recent.");
  }
}


void cmd_ntp(Stream &src) {
    src.println("📋 Saved NTP list:");
    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) > 0) {
            src.printf("%d: %s\n", i + 1, ntpList[i]);
        }
    }
    checkNtpStatus(src);
}

void cmd_addntp(const char *ntp, Stream &src) {
    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) == 0) {
            strncpy(ntpList[i], ntp, sizeof(ntpList[i]));
            saveNTPSettings();
            src.printf("✅ New NTP added: %s\n", ntp);

            // 👉 Optional: auto sync after adding
            syncNTP(src);

            return;
        }
    }
    src.println("⚠️ NTP list full. Delete old entry first.");
}
void cmd_removentp(int index, Stream &src) {
    if (index < 1 || index > MAX_NTP) {
        src.println("⚠️ Invalid index.");
        return;
    }

    index--;  // 1-based to 0-based
    memset(ntpList[index], 0, sizeof(ntpList[index]));
    saveNTPSettings();
    src.printf("✅ NTP entry %d removed.\n", index + 1);
}
void cmd_clearntp(Stream &src) {
    for (int i = 0; i < MAX_NTP; i++) {
        memset(ntpList[i], 0, sizeof(ntpList[i]));
    }
    saveNTPSettings();
    src.println("✅ All NTP entries cleared.");
}
// End NTP server settings


// WIFI settings
#define MAX_WIFI 5
struct WiFiEntry {
    char ssid[32];
    char pass[32];
};
WiFiEntry wifiList[MAX_WIFI];

void loadWiFiSettings() {
    prefs.begin("engine-hour", true);
    prefs.getBytes("wifiList", wifiList, sizeof(wifiList));
    prefs.end();
}
void saveWiFiSettings() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("wifiList", wifiList, sizeof(wifiList));
    prefs.end();
    Serial.println("💾 WiFi settings saved!");
}

void connectWiFi() {
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) == 0) continue;

        printAll("🔍 Trying WiFi: %s\n", wifiList[i].ssid);
        // // Added on Oct 10,2025 -- 
        WiFi.mode(WIFI_STA);
        WiFi.begin(wifiList[i].ssid, wifiList[i].pass);

        WiFi.persistent(false);
        WiFi.setAutoConnect(false);
        WiFi.setAutoReconnect(true);
        // WiFi.setTxPower(WIFI_POWER_2dBm);// Reduce power to 2dBm

        if (WiFi.waitForConnectResult() == WL_CONNECTED) {
            printAll("✅ WiFi connected!");
            printAll("IP Address: ");
            printAll(WiFi.localIP().toString().c_str());
            // Added on June 29,2025 -- To support NTP in-case of no wifi (prolonged power outage)
            // syncNTP(Serial);  // Sync NTP after connecting

            return;
        } else {
            printAll("⚠️ Failed, trying next...");
        }
    }

    printAll("❌ No WiFi connected.");
}
void cmd_wifi(Stream &src) {
    if (WiFi.isConnected()) {
        src.printf("✅ Connected WiFi: %s (%s), IP: %s\n",
                   WiFi.SSID().c_str(),
                   WiFi.BSSIDstr().c_str(),
                   WiFi.localIP().toString().c_str());
    } else {
        src.println("❌ Not connected to any WiFi.");
    }

    src.println("📋 Saved WiFi list:");
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) > 0) {
            // src.printf("%d: %s / %s\n", i + 1, wifiList[i].ssid, wifiList[i].pass);
            src.printf("%d: %s / *********\n", i + 1, wifiList[i].ssid);
        }
    }
}
void cmd_addwifi(const char *ssid, const char *pass, Stream &src) {
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) == 0) {
            strncpy(wifiList[i].ssid, ssid, sizeof(wifiList[i].ssid));
            strncpy(wifiList[i].pass, pass, sizeof(wifiList[i].pass));
            saveWiFiSettings();
            src.printf("✅ New WiFi added: %s / %s\n", ssid, pass);
            return;
        }
    }
    src.println("⚠️ WiFi list full. Delete old entry first.");
}
void cmd_removewifi(int index, Stream &src) {
    if (index < 1 || index > MAX_WIFI) {
        src.println("⚠️ Invalid index.");
        return;
    }

    index--;  // 1-based to 0-based
    memset(&wifiList[index], 0, sizeof(WiFiEntry));
    saveWiFiSettings();
    src.printf("✅ WiFi entry %d removed.\n", index + 1);
}
void cmd_clearwifi(Stream &src) {
    memset(wifiList, 0, sizeof(wifiList));
    saveWiFiSettings();
    src.println("✅ All WiFi entries cleared.");
}



// MQTT settings
#define MAX_MQTT 3
struct MqttServerEntry {
    char host[48];    // IP or domain
    uint16_t port;
    char username[32];
    char password[32];
};


void loadMqttFromPrefs() {
    prefs.begin("mqtt", false);

    prefs.getString("host", mqttHost, sizeof(mqttHost));
    mqttPort = prefs.getUShort("port", 1883);
    prefs.getString("user", mqttUser, sizeof(mqttUser));
    prefs.getString("pass", mqttPass, sizeof(mqttPass));

    prefs.end();

    mqttClient.setServer(mqttHost, mqttPort);

    Serial.printf("📡 MQTT loaded: %s:%d User:%s\n", mqttHost, mqttPort, mqttUser);
}
void saveMqttToPrefs() {
    prefs.begin("mqtt", false);

    prefs.putString("host", mqttHost);
    prefs.putUShort("port", mqttPort);
    prefs.putString("user", mqttUser);
    prefs.putString("pass", mqttPass);

    prefs.end();

    Serial.println("💾 MQTT settings saved!");
}

void cmd_mqtt(Stream &src) {
    src.println("🔎 MQTT Settings:");
    src.printf("  Host: %s\n", mqttHost);
    src.printf("  Port: %u\n", mqttPort);
    src.printf("  User: %s\n", (strlen(mqttUser) > 0) ? mqttUser : "(none)");
    src.printf("  Pass: ***********\n");
    src.printf("  Status: %s\n", mqttClient.connected() ? "Connected" : "Not connected");
}

void cmd_addmqtt(char *args, Stream &src) {
  prefs.begin("mqtt", false);
  prefs.putString("host", mqttHost);
  prefs.putUShort("port", mqttPort);
  prefs.putString("user", mqttUser);
  prefs.putString("pass", mqttPass);
  prefs.end();

}

void ensureMqttConnected() {
    if (!WiFi.isConnected()) {
        return; // No WiFi — skip
    }

    if (!mqttClient.connected()) {
        unsigned long now = millis();
        if (now - mqttLastConnectAttempt >= mqttReconnectInterval) {
            printAll("🔄 Attempting MQTT connect to %s:%u ...\n", mqttHost, mqttPort);

            bool connected = false;
            mqttClient.setKeepAlive( 180 ); // setting keep alive to 180 seconds
            if (strlen(mqttUser) > 0) {
                connected = mqttClient.connect(engine_name.c_str(), mqttUser, mqttPass);
            } else {
                connected = mqttClient.connect(engine_name.c_str());
            }

            if (connected) {
                printAll("✅ MQTT connected.");
            } else {
                printAll("⚠️ MQTT connect failed (state=%d)\n", mqttClient.state());
            }

            mqttLastConnectAttempt = now;
        }
    }

    // Must call loop always
    mqttClient.loop();
}

// End MQTT settings

void initializeConfig() {

  prefs.begin("engine-hour", true);  // read-only

  totalEngineHours = prefs.getFloat("totalHours", 0.0);
  totalEngineMinutes = prefs.getFloat("totalMins", 0.0);
  totalMoves = prefs.getULong("totalMoves", 0);



  // prefs.getBytes("ntpServer", ntpServer, sizeof(ntpServer));
  prefs.getBytes("engineName", engineName, sizeof(engineName));
  mqttHostPort(); // to split mqttServer into host and port

  prefs.end();
  Serial.printf("✅ Loaded Hours=%.2f Moves=%u Name=%s\n",
      totalEngineHours, totalMoves, engineName);

}

void saveConfig() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("engineName", engineName, sizeof(engineName));
    prefs.putFloat("totalHours", totalEngineHours);
    prefs.putFloat("totalMins", totalEngineMinutes);
    // prefs.putBytes("mqttServer", mqttServer, sizeof(mqttServer));
    prefs.putULong("totalMoves", totalMoves);


    prefs.end();

    printAll("💾 Saved Hours=%.2f Moves=%u \n",
      totalEngineHours, totalMoves);
}




// Wifi indicator
void checkRunningAndDisplay() {
  // Clear the dot area first
  display.fillRect(0, 50, 10, 10, BLACK);

  if (engineRunning) {
    // Handle blinking
    if (millis() - lastRunningBlinkTime >= RUNNING_BLINK_INTERVAL) {
      runningBlinkState = !runningBlinkState;
      lastRunningBlinkTime = millis();
    }

    if (runningBlinkState) {
      display.fillCircle(4, 60, 2, WHITE);  // Draw blinking dot
    }
  }
  // else: don't show anything (area already cleared)
}

void showWifiStatus(bool connected) {
  static bool blinkState = false;
  static unsigned long lastBlink = 0;
  const int blinkInterval = 500;  // Blink every 500ms

  if (connected) {
    display.drawBitmap(0, 0, wifi_icon, 16, 16, WHITE);

  }
}

void showMQTTStatus(bool connected) {
  if (connected) {
      display.drawBitmap(20, 0, chain_icon, 10, 10, WHITE);  // Draw in bottom-left
  } 
}


void onBuzzer(bool on) {
  if (!on) {
    digitalWrite(BUZZER_PIN, HIGH);  // ensure buzzer is off
    return;
  }

  if (millis() - lastBuzzerToggle >= 1000) {
    buzzerLogicState = !buzzerLogicState;
    digitalWrite(BUZZER_PIN, buzzerLogicState ? HIGH : LOW);  // active LOW logic
    lastBuzzerToggle = millis();
  }
}



// void connectWiFi(char* ssid, char* pass) {

//   Serial.print("Connecting to ");
//   Serial.println(ssid);

//   WiFi.begin(ssid, pass);
//   unsigned long start = millis();
//   while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
//     delay(500);
//     Serial.print(".");
//   }

//   // display.clearDisplay();

// if (WiFi.status() == WL_CONNECTED) {
//     Serial.println("\n✅ WiFi connected!");
//   } else {
//     Serial.println("\n❌ WiFi connection failed.");

//   }

// }


void loadSaveInterval() {

}

void showMessage(const String& message) {
  static bool visible = true;
  static unsigned long lastBlink = 0;
  const unsigned long blinkInterval = 500;  // milliseconds

  unsigned long now = millis();
  if (now - lastBlink >= blinkInterval) {
    visible = !visible;
    lastBlink = now;

    display.clearDisplay();
    display.fillScreen(SSD1306_WHITE);                 // White background

    if (visible) {
      display.setTextColor(SSD1306_BLACK);             // Black text
      display.setTextSize(2);

      int16_t x1, y1;
      uint16_t w, h;
      display.getTextBounds(message, 0, 0, &x1, &y1, &w, &h);

      int16_t x = (display.width() - w) / 2;
      int16_t y = (display.height() - h) / 2;
      display.setCursor(x, y);
      display.print(message);
    }

    display.display();
  }
}




void startEngine() {
  engineRunning = true;
  // engineStartTime = rtc.now().unixtime();
  lastSaveTime = millis();
  printlnBoth("✅ Engine running.");
}

void stopEngine() {
  if (engineRunning) {
    // updateEngineHours();
    // saveEngineHours();
    engineRunning = false;
    digitalWrite(LED_PIN, HIGH);
    printlnBoth("❌ Engine stop.");
  }
}

void sendToMqtt(const char* topic, const char* payload) {
    if (mqttClient.connected()) {
        mqttClient.publish(topic, payload);
        Serial.printf("✅ Published [%s]: %s\n", topic, payload);
    } else {
        Serial.println("⚠️ MQTT not connected.");
    }
}


void publish_data(){

      // reconnectMQTT(); // Reconnect MQTT if needed and see if any MQTT server is connected
      printAll("✅ Start sending data to MQTT servers\n");

        // Edit on Sep 11,2025 -- Send raw minutes as integer
        if (lastSentEngineMinutes  != totalEngineMinutes) {
            float hours = totalEngineMinutes / 60.0;
            char payload_totalhour[16];
            dtostrf(hours, 1, 2, payload_totalhour);
            // sprintf(payload_totalhour, "%ld", totalEngineMinutes);  // send raw minutes as integer

            String topic_hour = "engine/" + engine_name + "/hour";
            printAll("📡 Sending Hour (minutes): %s\n", payload_totalhour);

            sendToMqtt(topic_hour.c_str(), payload_totalhour);

            lastSentEngineMinutes  = totalEngineMinutes;
        }


        // Send Engine Total Move
        char payload_totalmove[12]; // Enough for int range
        itoa(totalMoves, payload_totalmove, 10);  // base 10
        String topic_move = "engine/" + engine_name + "/move";
        if (lastSentMove != totalMoves) {
            printAll("📡 Sending Move: %s\n", payload_totalmove);
            sendToMqtt(topic_move.c_str(),payload_totalmove);
            lastSentMove = totalMoves;  // Save last sent move  
        }

        // Send Engine malfunction
        String topic_malfunction = "engine/" + engine_name + "/malfunction";
        char engineCheckStr[10];  // Make sure the buffer is big enough
        itoa(engine_check, engineCheckStr, 10);  // 10 means base 10 (decimal)
        if (lastSentCheckEngine != engine_check) {
          printAll("📡 Sending Engine Check: %s\n", engineCheckStr);
          sendToMqtt(topic_malfunction.c_str(),engineCheckStr);
          lastSentCheckEngine = engine_check;  // Save last sent check engine status
        }

        // Send Battery Voltage
        if( abs(lastSentVoltage - lastValidVoltage) >= 0.3 ) { // Only send if change >= 0.3V
          lastSentVoltage = lastValidVoltage;
          // Method 1: Using snprintf   
          char batteryVoltageStr[10];
          String topic_battery_volt = "engine/" + engine_name + "/batt_volt";
          snprintf(batteryVoltageStr, sizeof(batteryVoltageStr), "%.2f", lastValidVoltage);
          printAll("📡 Sending Battery voltage: %s V\n", batteryVoltageStr);
          sendToMqtt(topic_battery_volt.c_str(), batteryVoltageStr);
        }

        prefs.begin("lastsent", false);  // true = read-only
          prefs.putUInt("lastMove", lastSentMove);
          prefs.putFloat("lastHour", lastSentHour);
          prefs.putUInt("lastCheckEngine", lastSentCheckEngine);
          prefs.putLong("lastMinute", lastSentEngineMinutes );
          prefs.putFloat("lastVolt", lastSentVoltage);
        prefs.end();

        printAll("✅ Done sending to MQTT.\n");
}

void showEngineFaultScreen() {
  display.clearDisplay();

  // Draw engine icon in center
  int iconX = 0;//(SCREEN_WIDTH - 16) / 2;
  int iconY = 8;
  display.drawBitmap(iconX, iconY, image_check_engine, 128, 64, WHITE);

  display.display();
}

void showOilChangeScreen() {
  display.clearDisplay();
  // Draw engine icon in center
  int iconX = 0;//(SCREEN_WIDTH - 16) / 2;
  int iconY = 8;
  // display.drawBitmap(iconX, iconY, image_battery, 128, 64, WHITE);
  display.drawBitmap(iconX, iconY, image_check_engine, 128, 64, WHITE);

  display.display();
}

void showAlertScreen(const uint8_t* image, const char* message) {
  display.clearDisplay();

  // Draw image in center
  int iconX = 0;//(SCREEN_WIDTH - 64) / 2;  // Adjust based on image width (e.g., 64)
  int iconY = 0;                        // Top-aligned
  display.drawBitmap(iconX, iconY, image, 128, 64, WHITE);

  // Draw bottom-centered message
  display.setTextSize(1);
  display.setTextColor(WHITE);

  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(message, 0, 0, &x1, &y1, &w, &h);
  int textX = (SCREEN_WIDTH - w) / 2;
  int textY = SCREEN_HEIGHT - h + 1;  // A bit above the bottom
  display.setCursor(textX, textY);
  display.print(message);

  display.display();

}

void updateDisplay(bool showNormalDisplay) {
    
    if (showNormalDisplay){
    display.clearDisplay();

    // Line 1: "Running" (if running) and engine name
    display.setTextSize(1);

  //  Not show Datetime -- to save space
    // struct tm timeinfo;
    // if (getLocalTime(&timeinfo)) {
    //     currentTime.year   = timeinfo.tm_year + 1900;
    //     currentTime.month  = timeinfo.tm_mon + 1;
    //     currentTime.day    = timeinfo.tm_mday;
    //     currentTime.hour   = timeinfo.tm_hour;
    //     currentTime.minute = timeinfo.tm_min;
    //     currentTime.second = timeinfo.tm_sec;
    //   }
    // display.setCursor(35, 0);  // adjust X for alignment if needed
    //  char buf[9];
    // sprintf(buf, "%d:%02d:%02d", currentTime.hour, currentTime.minute, currentTime.second);
    // display.print(buf);

    // Added on Oct 11,2025 -- To support Volt meter
    // float voltage = readCalibratedVoltage();
    display.setTextSize(1);
    display.setCursor(40, 0);
    display.print(lastValidVoltage, 2);
    display.println("v");
    // End Volt meter


   
    
    display.setCursor(96, 0);
    display.print(engineName);
  
 

    // Line 2: Big Total Hour in center
    display.setTextSize(2);
    char mainStr[12];
    int16_t x1, y1; uint16_t w, h;

      sprintf(mainStr, "%010.2f", totalEngineMinutes/60.0);

    display.getTextBounds(mainStr, 0, 0, &x1, &y1, &w, &h);
    display.setCursor(SCREEN_WIDTH - w, 25);
    display.print(mainStr);

    // Show Total move
    char moveStr[12];
    int16_t xm1, ym1; uint16_t wm, hm;
    sprintf(moveStr, "%10d", totalMoves); // pad total moves right-aligned

    display.getTextBounds(mainStr, 0, 0, &xm1, &ym1, &wm, &hm);
    display.setCursor(SCREEN_WIDTH - w, 48);
    display.print(moveStr);
  

      // checkWiFiStatusAndDisplay();
      checkRunningAndDisplay(); //Show blinking running



        // Show Wifi status

      #if defined(ESP32)
        showWifiStatus(WiFi.isConnected()); //show Wifi status
      #elif defined(ESP8266)
        showWifiStatus(WiFi.status() == WL_CONNECTED); //show Wifi status
      #endif

        // Show MQTT status
        if (mqttClient.connected()) {
          showMQTTStatus(true);
        } else {
          showMQTTStatus(false);
        }

        // Show engine fault if any
        if (engine_check) {
          showEngineFaultScreen();
        } else {
          display.display();
        }
  }
}

void blinkLED() {
  static unsigned long lastBlink = 0;
  static bool ledState = false;
  if (millis() - lastBlink >= 500) {
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState ? LOW : HIGH);
    lastBlink = millis();
  }
}



float readFloat(int addr) {
  float val;
  // EEPROM.get(addr, val);
  return (isnan(val) || val < 0) ? 0.0 : val;
}



void writeName(String name, Stream &src) {
  engine_name = name;
  name.toCharArray(engineName, 32);
  src.println("✅ change engine name successful.");
  saveConfig();  // Save to preferences
}



void writeShiftName(int addr, String name) {
  // for (int i = 0; i < MAX_NAME_LENGTH; i++) EEPROM.write(addr + i, name[i]);
  // EEPROM.commit();
}



void set_time(String input) {

  Serial.println("Time set.");
}

void show_time(Stream &out) {

   struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        currentTime.year   = timeinfo.tm_year + 1900;
        currentTime.month  = timeinfo.tm_mon + 1;
        currentTime.day    = timeinfo.tm_mday;
        currentTime.hour   = timeinfo.tm_hour;
        currentTime.minute = timeinfo.tm_min;
        currentTime.second = timeinfo.tm_sec;

        out.printf("Current time: %04d/%02d/%02d %02d:%02d:%02d\n",
            currentTime.year, currentTime.month, currentTime.day,
            currentTime.hour, currentTime.minute, currentTime.second);
    } else {
        out.println("Failed to obtain time.");
    }
}

void saveMovesToEEPROM() {

}



void handleSerialCommand(String cmd, Stream &src) {
  if (cmd == "hour") src.println(totalEngineMinutes/60.0, 2);
  else if (cmd.startsWith("sethour")) {
      totalEngineHours = cmd.substring(8).toFloat();
      totalEngineMinutes = totalEngineHours * 60;
      src.print("✅ Set hour: ");
      src.println(totalEngineMinutes / 60.0, 2);
  }
  else if (cmd == "name") src.println(engineName);
  else if (cmd.startsWith("setname")) writeName(cmd.substring(8, 18),src);
  else if (cmd == "time") show_time(src);
  else if (cmd == "interval") {
    src.printf("Current save interval: %lu seconds\n", SAVE_INTERVAL / 1000UL);
  }
  else if (cmd.startsWith("setinterval ")) {
    unsigned long sec = cmd.substring(12).toInt();
    if (sec > 0 && sec <= 86400) {
      // SAVE_INTERVAL = sec * 1000UL;
      // EEPROM.put(EEPROM_ADDR_INTERVAL, sec);
      // EEPROM.commit();
      src.printf("✅ Save interval set to: %lu seconds\n", sec);
    } else {
      src.println("Invalid value. Use 1–86400 seconds.");
    }
  }
  else if (cmd == "wifi") {
    cmd_wifi(src); // Show WiFi status
  } //end cmd.startsWith("wifi")
  else if (cmd == "wifi list") {
    src.println("Scanning Wi-Fi networks...");
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);
    int n = WiFi.scanNetworks();
    if (n == 0) {
      src.println("No networks found.");
    } else {
      src.printf("%d networks found:\n", n);
      for (int i = 0; i < n; ++i) {
        src.printf("%d: %s (%d dBm) %s\n", i + 1,
          WiFi.SSID(i).c_str(),
          WiFi.RSSI(i),
          #if defined(ESP32)
          (WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? "Open" : "Secured");
          #elif defined(ESP8266)
          (WiFi.encryptionType(i) == ENC_TYPE_NONE) ? "Open" : "Secured");
          #endif
      }
    }
  } else if ( cmd.startsWith("addwifi" )){
    int firstSpace = cmd.indexOf(' ');
    int secondSpace = cmd.indexOf(' ', firstSpace + 1);
    if (firstSpace != -1 && secondSpace != -1) {
      String ssid_str = cmd.substring(firstSpace + 1, secondSpace);
      String pass_str = cmd.substring(secondSpace + 1);
      char ssid[32], pass[32];
      ssid_str.toCharArray(ssid, 32);
      pass_str.toCharArray(pass, 32);
      cmd_addwifi( ssid, pass,src);
      connectWiFi();
    }else {
      src.println("Usage: addwifi SSID PASSWORD");
    }
  } else if ( cmd.startsWith("removewifi" )){
    cmd_removewifi(cmd.substring(11).toInt(), src);
  } else if ( cmd.startsWith("clearwifi" )){
    cmd_clearwifi(src);
  }
  // MOve
  else if (cmd == "move") {
    src.printf("%d", totalMoves);
  } else if (cmd.startsWith("setmove ")) {
    int newValue = cmd.substring(8).toInt();
    totalMoves = newValue;
    saveMovesToEEPROM();
    src.println("✅ Total move updated.");
  } else if (cmd == "mqtt") {
    cmd_mqtt(src); // Show MQTT status
  }
  else if (cmd.startsWith("addmqtt ")) {
    char argsChr[128];
    cmd.substring(8).toCharArray(argsChr, sizeof(argsChr));

    char host[64], user[32], pass[32];
    int port = 1883;

    int params = sscanf(argsChr, "%63[^:]:%d %31s %31s", host, &port, user, pass);

    if (params >= 2) {
        strcpy(mqttHost, host);
        mqttPort = port;

        if (params >= 4) {
            strcpy(mqttUser, user);
            strcpy(mqttPass, pass);
        } else {
            mqttUser[0] = 0;
            mqttPass[0] = 0;
        }

        mqttClient.setServer(mqttHost, mqttPort);

        // Save
        prefs.begin("mqtt", false);
        prefs.putString("host", mqttHost);
        prefs.putUShort("port", mqttPort);
        prefs.putString("user", mqttUser);
        prefs.putString("pass", mqttPass);
        prefs.end();

        Serial.printf("✅ MQTT saved: %s:%d User:%s\n", mqttHost, mqttPort, mqttUser);
    } else {
        Serial.println("⚠️ Invalid format! Use: addmqtt host:port [user] [pass]");
    }
} else if (cmd == "clearmqtt") {
    mqttHost[0] = 0;
    mqttPort = 1883;
    mqttUser[0] = 0;
    mqttPass[0] = 0;

    prefs.begin("mqtt", false);
    prefs.clear();
    prefs.end();

    mqttClient.disconnect();

    Serial.println("✅ MQTT settings cleared.");
} else if (cmd == "testmqtt") {
    if (mqttClient.connected()) {
        sendToMqtt("test/topic", "Hello from device!");
    } else {
        Serial.println("⚠️ MQTT not connected.");
    }
} else if (cmd == "mqttinterval") {
    src.print("MQTT Interval (sec): ");
    src.println(mqttSendInterval/1000);
  } else if (cmd.startsWith("setmqttinterval ")) {
    String param = cmd.substring(16);
    mqttSendInterval = param.toInt() * 1000UL;
    src.print("✅ MQTT Interval set to ");
    src.print(mqttSendInterval/1000);
    src.println(" sec");
  } else if (cmd.startsWith("pm ")){
    isPm = false;
    alertMsg = "";
    String msg = cmd.substring(3);
    if (msg.length() > 1){
        isPm = true;
        alertMsg = msg;
        src.println("✅ set PM message successful.");
    } else {
        src.println("✅ reset PM message successful.");
    }
  } else if (cmd == "moveminactive") { //MIn move active
    src.print("🕒 Move min active duration: ");
    src.print(minActiveMs/1000);
    src.println(" s");
  }
  else if (cmd.startsWith("setmoveminactive")) {
    int spaceIndex = cmd.indexOf(' ');
    if (spaceIndex != -1) {
      String valueStr = cmd.substring(spaceIndex + 1);
      int newMs = valueStr.toInt();

      minActiveMs = newMs*1000;
      // saveMinActiveMs();
      src.print("✅ Set move min active to ");
      src.print(minActiveMs/1000);
      src.println(" s");

    }
} else if (cmd == "ntp") {
  cmd_ntp(src); // Show NTP status
} else if (cmd.startsWith("addntp ")) {
    int firstSpace = cmd.indexOf(' ');
    if (firstSpace != -1) {
      char ntpServer_[32];
      String ntpServerStr = cmd.substring(firstSpace + 1);
      ntpServerStr.toCharArray(ntpServer_, 32);
      cmd_addntp(ntpServer_, src);
    } else {
      src.println("Usage: addntp <NTP_SERVER>");
    }
  } else if (cmd.startsWith("removentp ")) {
    int index = cmd.substring(10).toInt();
    if (index >= 0 && index < MAX_NTP ) {
      cmd_removentp(index, src);
    } else {
      src.println("Invalid index. Use 0 to 4.");
    }
  } 
  else if (cmd == "btmac") {
    printBluetoothMAC(src);
  }
  else if (cmd == "lastsent") {
    src.printf("Hour: %.2f\n", lastSentHour);
    src.printf("Minute: %u\n", lastSentEngineMinutes);
    src.printf("Move: %u\n", lastSentMove);
    
  }
  // Added on Oct 12,2025 -- For Volatage calibration
  else if(cmd.startsWith("vref ")){
     int spaceIndex = cmd.indexOf(' ');
      if (spaceIndex != -1) {
        String valueStr = cmd.substring(spaceIndex + 1);
        float vref = valueStr.toFloat();
        measureReferenceVoltage(src,vref);
      }
  }
   if (cmd.startsWith("lowpoint")) {
      // startTwoPointCalibration(src);
      lowPointCalibration(src,21);
    }
    else if (cmd.startsWith("highpoint")) {
        // startTwoPointCalibration(src);
        highPointCalibration(src,29);
      }
      // calculateCalibration
    else if (cmd == "calibrate") {
        calculateCalibration(src);
      }
    //  showAccuracyInfo
    else if (cmd == "accuracy") {
        showAccuracyInfo(src);
      }
      else if (cmd.startsWith("R ")) {
      int spaceIndex = cmd.indexOf(' ');
      if (spaceIndex != -1) {
        String valueStr = cmd.substring(spaceIndex + 1);
        setResistorsCommand(src,cmd);
      }
        
      }
  else if (cmd == "help") {
    src.println("Available commands:");
    src.println("1 - Start engine");
    // src.println("0 - Stop engine");
    src.println("hour - Show total engine hours");
    src.println("sethour <value> - Set total engine hours");
    src.println("name - Show engine name");
    src.println("setname <name> - Set engine name");
    src.println("time - Show current time");
    src.println("interval - Show save interval in seconds");
    src.println("setinterval <seconds> - Set save interval in seconds (1-86400)");
    src.println("wifi - Show WiFi status");
    src.println("wifi list - List available WiFi networks");
    src.println("addwifi <SSID> <PASSWORD> - Add a new WiFi network");
    src.println("removewifi <index> - Remove a WiFi network by index");
    src.println("clearwifi - Clear all saved WiFi networks");
    src.println("move - Show total moves count");
    src.println("setmove <count> - Set total moves count");
    src.println("mqtt - Show MQTT server and connection status");
    src.println("setmqtt <server:port> - Set MQTT server and port");
    src.println("mqttinterval - Show MQTT send interval in seconds");
    src.println("setmqttinterval <seconds> - Set MQTT send interval in seconds (default 10)");
    src.println("testmqtt - Test MQTT connection with current settings");
    src.println("pm <message> - Set PM message or reset it if empty");
    src.println("btmac - Show Bluetooth MAC address");
    src.println("lastsent - Show last sent data to MQTT");
}
}



// MQTT Callback
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String msg;
  for (uint i = 0; i < length; i++) msg += (char)payload[i];

  String topic_res =  "engine/" + engine_name + "/resp";
  if (msg.startsWith("sethour:")) {
    float newHour = msg.substring(8).toFloat();
    // engineHour = newHour;
    totalEngineHours = newHour;
    totalEngineMinutes = totalEngineHours * 60;
    saveConfig();
    sendToMqtt(topic_res.c_str(),("OK sethour=" + String(totalEngineHours, 2)).c_str());
    // client.publish("engine/RS10/resp", ("OK sethour=" + String(totalEngineHours, 2)).c_str());
  }
  else if (msg == "gethour") {
    sendToMqtt(topic_res.c_str(),("hour=" + String(totalEngineHours, 2)).c_str());
    // client.publish("engine/RS10/resp", ("hour=" + String(totalEngineHours, 2)).c_str());
  }
  else if (msg.startsWith("setmove:")) {
    int newMove = msg.substring(8).toInt();
    totalMoves = newMove;
    saveConfig();
    sendToMqtt(topic_res.c_str(),("OK setmove=" + String(totalMoves)).c_str());
    // client.publish("engine/RS10/resp", ("OK setmove=" + String(totalMoves)).c_str());
  }
  else if (msg == "getmove") {
    // client.publish("engine/RS10/resp", ("move=" + String(totalMoves)).c_str());
    sendToMqtt(topic_res.c_str(),("move=" + String(totalMoves)).c_str());
  }
}




void setup(){
  Wire.begin(OLED_SDA, OLED_SCL);
  // Initialize the display
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("SSD1306 not found");
    while (true);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  showAlertScreen(image_company,"LOADING.....");
  display.display();

  // Added on Oct 10,2025 Disable WiFi power save mode
  // This helps maintain a stable connection
  esp_wifi_set_ps(WIFI_PS_NONE);
  esp_wifi_set_max_tx_power(82); // Set TX power to maximum (20.5 dBm)
// For RX gain, it's more complex and often requires IDF APIs directly

  Serial.begin(115200);

    // Initialize ADC for best accuracy
    analogReadResolution(12);     // 12-bit resolution (0-4095)
    analogSetAttenuation(ADC_11db); // 0-3.3V range
    analogSetClockDiv(1);
    // End ADC init
  
    // loadResistorValues(Serial); // Load saved resistor values
    loadCalibration();

    pinMode(LED_PIN, OUTPUT);
    // pinMode(ENGINE_INPUT_PIN, INPUT_PULLUP); //for Hour
    

    #ifndef INPUT_PULLDOWN
    #define INPUT_PULLDOWN INPUT_PULLDOWN_16
    #endif
    // pinMode(ENGINE_INPUT_PIN, INPUT_PULLDOWN); //for Hour
    // pinMode(MOVE_INPUT_PIN, INPUT_PULLDOWN); //for move
    // pinMode(CHECK_ENGINE_INPUT_PIN,INPUT_PULLDOWN);//for Display mode UP=Hour,DOWN=Move
    
    // Fix voltage issue on ESP32 , R1= 76K and R2=10K
    // INPUT_PULLDOWN , internal resistance will be 45K
    // External resistance will be 10K, thus total resistance will be 8.5K
    // Thus voltage on pin will be 24V * 8.5K / (    76K + 8.5K) = 2.5V (safe for ESP32)

    pinMode(ENGINE_INPUT_PIN, INPUT); //for Hour  
    pinMode(CHECK_ENGINE_INPUT_PIN,INPUT);//for Display mode UP=Hour,DOWN=Move
    pinMode(MOVE_INPUT_PIN, INPUT); //for move

    pinMode(BUZZER_PIN, OUTPUT);
    digitalWrite(BUZZER_PIN, HIGH);  // For active-LOW buzzer (OFF)
   // Initialize EEPROM 
    initializeConfig();

    // connectWiFi(wifiSSID, wifiPASS);
    loadWiFiSettings();
    loadNTPSettings();
    // loadMqttList();

    // connectWiFi();
  
    loadMqttFromPrefs();

    // Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
    // prefs.begin("ntp", true);
    // lastNtpSyncEpoch = prefs.getUInt("lastsync", 0);
    // prefs.end();

    // Oct 12,2025 -- Not restore last NTP sync time here
    //   prefs.begin("ntp", true);
    //     if (prefs.isKey("lastsync")) {
    //       lastNtpSyncEpoch = prefs.getULong("lastsync");
    //       Serial.printf("🕒 Restored last NTP sync: %s", ctime((time_t*)&lastNtpSyncEpoch));
    //     } else {
    //       lastNtpSyncEpoch = 0;
    //       Serial.println("⚠️ No previous NTP sync time found.");
    //     }
    //   prefs.end();

    // printAll("🕒 Last NTP sync at epoch: %lu (%s)\n",
    //           lastNtpSyncEpoch,
    //           ctime((time_t*)&lastNtpSyncEpoch));

    engine_name = String(engineName);
    if (engine_name.length() == 0) {
      engine_name = "Engine1"; // Default name
      // writeName(engine_name, Serial);
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    // Added July 29,2025 -- To load saved hours and moves
    prefs.begin("lastsent", true);  // true = read-only
    lastSentHour = prefs.getUInt("lastHour", 0);
    lastSentMove = prefs.getFloat("lastMove", 0.0);
    lastSentCheckEngine = prefs.getUInt("lastCheckEngine", 0);
    lastSentBattery = prefs.getFloat("lastVolt", 0.0);

    lastSentEngineMinutes = prefs.getLong("lastMinute", 0.0);
    prefs.end();

    // For Enable Bluetooth
    
    #if defined(ESP32)
      btEnable = SerialBT.begin(engine_name);
      SerialBT.println("Bluetooth is ready");
    #endif

    Serial.println("Bluetooth started! Waiting for connections...");

    // Oct 12,2025
    // Remark: Do not call NTP sync here, as WiFi may not be connected yet
    // if (WiFi.status() == WL_CONNECTED) {
    //   syncNTP(Serial);
    // }


}






// Counting Move
void checkMoveInput() {
  bool reading = digitalRead(MOVE_INPUT_PIN);

  // Debounce handling
  if (reading != lastMoveButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > DEBOUNCE_DELAY_MS) {
    // If stable reading and changed
    if (reading != moveButtonState) {
      moveButtonState = reading;

      if (moveButtonState == HIGH) {
        highStartTime = millis(); // Start timing the HIGH state
        highStable = true;
        isLifting = true;         // ✅ Set AFTER debounce confirmed HIGH
      }
      else if (moveButtonState == LOW && highStable) {
        // Check how long it stayed HIGH
        if (millis() - highStartTime >= minActiveMs) {
          // Check if engine running then increase moving
          printlnBoth("✅ Move On.");
          if (engineRunning) {
            totalMoves++;

          }//end check engingRunning

          isLifting = false;

        }
        highStable = false;  // Reset
        isLifting = false;        // ✅ End lifting after LOW
      }
    }
  }

  lastMoveButtonState = reading;
}
// End Counting Move

// void resyncNTP_period() {
//   if (WiFi.status() == WL_CONNECTED) {
//     struct tm timeinfo;
//     if (getLocalTime(&timeinfo)) {
//         currentTime.year   = timeinfo.tm_year + 1900;
//         currentTime.month  = timeinfo.tm_mon + 1;
//         currentTime.day    = timeinfo.tm_mday;
//         currentTime.hour   = timeinfo.tm_hour;
//         currentTime.minute = timeinfo.tm_min;
//         currentTime.second = timeinfo.tm_sec;

//         // Morning resync at 07:30
//         if (currentTime.hour == 8 && currentTime.minute == 05) {
//             if (!resyncDoneMorning) {
//                 Serial.println("⏰ Morning NTP Resync...");
//                 // synchroniseWith_NTP_Time(Serial);
//                 syncNTP(Serial);
//                 resyncDoneMorning = true;
//             }
//         } else {
//             resyncDoneMorning = false; // reset flag after minute passes
//         }

//         // Evening resync at 19:30 (7:30 PM)
//         if (currentTime.hour == 20 && currentTime.minute == 05) {
//             if (!resyncDoneEvening) {
//                 Serial.println("⏰ Evening NTP Resync...");
//                 // synchroniseWith_NTP_Time(Serial);
//                 syncNTP(Serial);
//                 resyncDoneEvening = true;
//             }
//         } else {
//             resyncDoneEvening = false;
//         }
//     }
  

//   }
// }

void loop(){
      unsigned long now = millis();
    if (now - lastSaveMillis > SAVE_INTERVAL) {
        lastSaveMillis = now;
        saveConfig();
    }

          // Watchdog: check every 2 minute
      if (millis() - lastNtpAttempt > 2*60*1000) {
        lastNtpAttempt = millis();

        if (WiFi.status() != WL_CONNECTED) {
          printAll("🔄 WiFi disconnected — trying to reconnect...");
          // WiFi.begin(ssid, pass);
          connectWiFi();
        } 
        //comment on Oct 12,2025 -- Do not try to synce NTP if not connected to WiFi
        // else if (!ntpSynced) {
        //   printAll("🔄 Trying NTP sync again...");
        //   syncNTP(Serial);
        // }
      }

      // Check if we need to resync NTP periodically
     //comment on Oct 12,2025 -- Do not try to synce NTP if not connected to WiFi
      // if (millis() - lastCheck > 4UL * 60UL * 60UL * 1000UL) {  // Every 4 hours
      //   syncNTP(Serial);
      //   lastCheck = millis();
      // }
      // End NTP resync

      // Added on Oct 11,2025 -- To support Volt meter
      // float stableVolt = readStableVoltage();
      // // Update display only every 500ms or if change > 0.2V     
      // if (abs(stableVolt - lastValidVoltage) > 0.2 || millis() - lastVoltageCheck > 60UL * 1000UL) {
      //   lastValidVoltage = stableVolt;
      //   lastVoltageCheck = millis();
      // }
        // float stableVolt = readCalibratedVoltage();
        // float stableVolt = readStableVoltage();
         float stableVolt = readPreciseVoltage();
        // Update display only every 500ms or if change > 0.2V     
        if (abs(stableVolt - lastValidVoltage) > 0.2 || millis() - lastVoltageCheck > 60UL * 1000UL) {
        lastValidVoltage = stableVolt;
        lastVoltageCheck = millis();
        }
      // End Volt meter

    if (Serial.available()) {
      String cmd = Serial.readStringUntil('\n');
      cmd.trim();
      handleSerialCommand(cmd,Serial);
    }
    // To support Bluetooth
    #if defined(ESP32)
    if (SerialBT.available()) {
      String cmd = SerialBT.readStringUntil('\n');
      cmd.trim();
      handleSerialCommand(cmd,SerialBT);
    }
    #endif

    // for check input
    // If fou d any problem , Display will change to Alert mode
    if(isCheckEngine || isPm || isChargeFail || isLifting){
      alertDisplay = true;
      if(isCheckEngine || isPm) onBuzzer(true);
    }else{
      alertDisplay = false;
      onBuzzer(false);
    }

    if (isCheckEngine){
      showAlertScreen(image_check_engine,"SYSTEM FAULT!");
    }
    if (isPm){
      showAlertScreen(image_oil_change,alertMsg.c_str());
    }

    // Handle Move count
    checkMoveInput();
    if (isLifting){
      showAlertScreen(image_move_up,"LIFTING");
    }
    
    if (engineRunning && millis() - lastMinuteUpdate >= 60000) {
      totalEngineMinutes++;
      totalEngineHours = totalEngineMinutes /60.0;
      lastMinuteUpdate = millis();  // Reset timer
    }

    bool engineSignal = digitalRead(ENGINE_INPUT_PIN) == HIGH;
    if (engineSignal && !engineRunning) startEngine();
    else if (!engineSignal && engineRunning) {
      stopEngine();
    }
    // End input

    // send MQTT data every mqttSendInterval
    if (millis() - lastMQTTSendTime >= mqttSendInterval) {  
      if (WiFi.status() == WL_CONNECTED) {
        // Send Engine Total Hour
        // ensureMqttConnected(); //July 12 -- Comment this line if you want to send data without checking MQTT connection
        publish_data();
      } else {
        // Optional: Retry MQTT connection here (or just skip)
        printAll("MQTT/WiFi unavailable. Skipping send.");
      }
      lastMQTTSendTime = millis();
    }
    // End send MQTT data

    // if (WiFi.isConnected()) {
    //   if (!mqttClient.connected()) {
    //       if (strlen(mqttUser) > 0) {
    //           mqttClient.connect("client_id", mqttUser, mqttPass);
    //       } else {
    //           mqttClient.connect("client_id");
    //       }

    //       // if (mqttClient.connected()) {
    //       //     Serial.println("✅ MQTT connected!");
    //       // } else {
    //       //     Serial.println("⚠️ MQTT connect failed.");
    //       // }
    //   }

    //     mqttClient.loop();
    // }

    ensureMqttConnected();
    // mqttClient.loop();

    updateDisplay(!alertDisplay);
    delay(100); // Add a small delay to avoid busy loop

}

  


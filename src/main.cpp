#include <Arduino.h>
// Version 3.0 - Dual Shift Support with Named Shifts

#include <Wire.h>
#include <Adafruit_GFX.h>
#define SSD1306_NO_SPLASH 1
#include <Adafruit_SSD1306.h>



#if defined(ESP8266)
  #define OLED_SDA 4
  #define OLED_SCL 5
  #include <ESP8266WiFi.h>
#elif defined(ESP32)
  #include <WiFi.h>
  #include "BluetoothSerial.h"
  BluetoothSerial SerialBT;
  // For LOLIN32 Lite
  // #define OLED_SDA 25
  // #define OLED_SCL 26

  // For Stardard ESP32 boards
  #define OLED_SDA 21
  #define OLED_SCL 22
#else
  #error "Unsupported board"
#endif

#include <PubSubClient.h>

// WiFiClient espClient;  // ✅ Declare once globally
// PubSubClient mqttClient(espClient);  // Use it for MQTT, etc.


#include "time.h"
// char ntpServer[32] = "pool.ntp.org";//"bdc-lcb1.lcb1.com";//

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);


#define ENGINE_INPUT_PIN 27
#define LED_PIN 25
#define CHECK_ENGINE_INPUT_PIN 12//DISPLAY_MODE_INPUT_PIN

#define MOVE_INPUT_PIN 14

#define MAX_SERVER_LEN       32


#define LED_FLASH_DURATION 200  // milliseconds
bool flashActive = false;
unsigned long flashStartTime = 0;
// End move

const int EEPROM_ADDR_INTERVAL = 51;


const unsigned long DISPLAY_UPDATE_INTERVAL = 1000;

// String engine_name = "";
bool engineRunning = false;
unsigned long engineStartTime = 0;
unsigned long lastSaveTime = 0;
unsigned long lastDisplayUpdate = 0;
// float totalEngineHours = 0;


bool wasEngineRunning = false;

int lastShift1ResetDay = -1;
int lastShift2ResetDay = -1;


int lastShiftIndex = -1;

unsigned long lastMQTTSendTime = 0;
unsigned long mqttSendInterval = 5*60*1000; // default 5 minutes
// End MTTQ

bool alertDisplay = false; //Show Normal mode(Engine hour) or Alert mode (check engine,Batt,PM)
int engine_check = 0; //IN case found Check Engine alram set to 1

String alertMsg = "";
bool isPm = false;
bool isCheckEngine = false;
bool isChargeFail = false;
bool isLifting = false;

// Constants
#define EEPROM_MIN_ACTIVE_ADDR 300  // Choose an unused EEPROM address
#define DEBOUNCE_DELAY_MS 50     // Debounce time
#define MIN_ACTIVE_MS 10000        // Minimum time the input must stay HIGH to count (configurable)

// State variables
unsigned int minActiveMs = 10000;         // Default value 10 Sec
bool moveButtonState = LOW;             // Current stable state
bool lastMoveButtonState = LOW;         // Previous raw reading
unsigned long lastDebounceTime = 0;     // For debouncing
unsigned long highStartTime = 0;        // When HIGH state started
bool highStable = false;                // Track if HIGH was stable long enough


// Added on May 20,2025 -- To fix large number of Hour (long)
#define EEPROM_ADDR_TOTAL_MINUTES 310  // Use 4 bytes for unsigned long
unsigned long totalEngineMinutes = 0; // stores total runtime in minutes
unsigned long lastMinuteUpdate = 0;

// Wifi re-connect variable
unsigned long wifi_previousMillis = 0;
unsigned long wifi_interval = 30000;


// Buzzser
#define BUZZER_PIN 13  // or any suitable GPIO
unsigned long lastBuzzerToggle = 0;
bool buzzerLogicState = true; // start HIGH (silent for active-LOW)

// NTP server
#define NTP_ADDR 320 //Keep NTP server

// To show INPUT change state
bool lastStateMove = LOW;
bool lastStateCheckEngine = LOW;

// Running indecator
unsigned long lastRunningBlinkTime = 0;
bool runningBlinkState = false;
const int RUNNING_BLINK_INTERVAL = 500; // ms

// Reconnect MQTT
unsigned long lastMQTTAttempt = 0;
const long mqttRetryInterval = 10000; // 10 seconds
bool mqttConnected = false;

// Define your DateTime variable
struct MyDateTime {
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int second;
};

MyDateTime currentTime;

unsigned long lastNtpAttempt = 0;
bool ntpSynced = false;

char ssid[32], pass[32];

bool resyncDoneMorning = false;
bool resyncDoneEvening = false;




// Alert image
const uint8_t image_check_engine[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x7f, 0x87, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0xe4, 0x9e, 0x72, 0x41, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x24, 0x90, 0x9a, 0x81, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x07, 0x9c, 0x83, 0x81, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0x07, 0x9c, 0x83, 0x81, 0xfc, 0x18, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0x24, 0x90, 0x9a, 0x40, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0xe4, 0x9e, 0x72, 0x60, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xe9, 0x19, 0x41, 0xc0, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x09, 0x65, 0x61, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xcd, 0x41, 0x71, 0xc0, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x0b, 0x4d, 0x59, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0x0b, 0x65, 0x49, 0x00, 0xfc, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe1, 0xe9, 0x39, 0x49, 0xe1, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x01, 0xce, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xce, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x01, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x01, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};



const uint8_t image_oil_change[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x03, 0x80, 0x00, 0x07, 0xff, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x79, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xfe, 0x08, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x78, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0x1c, 0x00, 0x00, 0x1f, 0xe3, 0xe0, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3e, 0x1c, 0x00, 0x00, 0x0f, 0x07, 0xc0, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1e, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0f, 0x1c, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0xdc, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// const GFXglyph customGlyph = { image_data, 128, 64, 128, 0, 0 };
// const GFXfont customFont = { (uint8_t *)image_data, &#038;customGlyph, 32, 127, 64 };

// const uint8_t image_battery[] PROGMEM = {
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x07, 0xf0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0c, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0c, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x18, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x18, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x7c, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0xfc, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0x0c, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x30, 0x18, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x3f, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0xc0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// };

// const uint8_t image_clock_error[] PROGMEM = {
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x3f, 0xfe, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x03, 0xff, 0xff, 0xc0, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x0f, 0xff, 0xff, 0xf8, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x3f, 0xff, 0xff, 0xfc, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xff, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0xff, 0x80, 0x01, 0xff, 0x83, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x3f, 0x83, 0xfe, 0x00, 0x00, 0x3f, 0xe1, 0xfc, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x1f, 0x07, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0xf8, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0xe0, 0x00, 0x00, 0x03, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x06, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfc, 0x60, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x01, 0x80, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x01, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x01, 0x80, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x01, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x01, 0x80, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x01, 0x80, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x01, 0x80, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x01, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x03, 0xff, 0xfe, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe7, 0xff, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0xff, 0xff, 0x81, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x0f, 0xf8, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
// };

const uint8_t image_move_up[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x91, 0x11, 0x11, 0x08, 0x88, 0x8b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x9b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x91, 0x10, 0x00, 0x00, 0x00, 0x8b, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t image_company[] PROGMEM = {
0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x3f, 0xc0, 0x03, 0xf9, 0xff, 0x80, 0xff, 0xff, 0xff, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x3f, 0xc0, 0x0f, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3f, 0xc0, 0x3f, 0xff, 0xff, 0x81, 0xff, 0xff, 0xfe, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x1f, 0x00, 0x7f, 0x9f, 0xbf, 0xc1, 0xff, 0xe7, 0xce, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3b, 0x83, 0xbc, 0xc7, 0x86, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf8, 0x07, 0x7f, 0xc7, 0xfd, 0xc7, 0x8e, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf0, 0x00, 0x33, 0xc7, 0x3c, 0x0f, 0x80, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3e, 0x01, 0xf0, 0x00, 0x73, 0xcf, 0x7c, 0x0f, 0x80, 
0x03, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x3c, 0x01, 0xe0, 0x00, 0x73, 0xce, 0x78, 0x0f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0xc0, 0x00, 0x7c, 0x1f, 0xe0, 0x00, 0x73, 0xfe, 0x78, 0x1f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3f, 0xf0, 0x00, 0xf3, 0xfc, 0xf8, 0x1f, 0x00, 
0x01, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3f, 0xf0, 0x08, 0xe3, 0xf8, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x80, 0x00, 0x7c, 0x3d, 0xf0, 0x1e, 0xe3, 0xf8, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x7c, 0x3d, 0xf8, 0x7f, 0xe1, 0xf0, 0xf8, 0x1f, 0x00, 
0x00, 0xff, 0xc0, 0x01, 0xff, 0x00, 0x01, 0xff, 0xf8, 0xff, 0xff, 0xf1, 0xe3, 0xfc, 0x7f, 0x80, 
0x00, 0x7f, 0xc0, 0x01, 0xfe, 0x00, 0x01, 0xff, 0xf8, 0x7f, 0xf7, 0xf1, 0xe7, 0xfc, 0xff, 0x80, 
0x00, 0x3f, 0xc0, 0x01, 0xfe, 0x00, 0x03, 0xff, 0xf8, 0x1f, 0xc7, 0xf1, 0xc7, 0xf8, 0xff, 0x80, 
0x00, 0x3f, 0xc0, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x1f, 0xc0, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xa9, 0x44, 0x00, 0x10, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xdf, 0xe0, 0xff, 0xff, 0x6b, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xdb, 0xe0, 0xdf, 0xf6, 0xeb, 0xfb, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xe0, 0xff, 0xf6, 0xfa, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xfd, 0xb0, 0xc6, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0xff, 0xff, 0xf0, 0x46, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0xff, 0xff, 0xfc, 0x47, 0xef, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t wifi_icon[] PROGMEM = {
0x07, 0xe0, 
0x1f, 0xf8, 
0x38, 0x1c, 
0x60, 0x06, 
0xc7, 0xe3, 
0x1c, 0x38, 
0x18, 0x18, 
0x13, 0xc8, 
0x07, 0xe0, 
0x04, 0x20, 
0x01, 0x80, 
0x01, 0x80, 
0x00, 0x00, 
0x00, 0x00, 
0x00, 0x00, 
0x00, 0x00, 
};

const uint8_t chain_icon[] PROGMEM = {
0x00, 0x00, 
0x06, 0x80, 
0x0c, 0x00, 
0x00, 0x80, 
0x35, 0x80, 
0x6b, 0x00, 
0x40, 0x00, 
0x08, 0x00, 
0x58, 0x00, 
0x00, 0x00, 
};


#include <Preferences.h>
Preferences prefs;

Preferences prefMqtt;
#define PREFNS "mqttprefs"

  String engine_name = "";
  float totalEngineHours = 0.0;
  float totalEngineMins = 0.0;
  uint32_t totalMoves = 0;


  char engineName[32] = "Engine-X";
  char mqttServer[32] = "192.168.1.100:1883";

  WiFiClient espClient;
  PubSubClient mqttClient(espClient);
  char mqttHost[64] = "";
  uint16_t mqttPort = 1883;
  char mqttUser[32] = "";
  char mqttPass[32] = "";

  unsigned long mqttLastConnectAttempt = 0;
  const unsigned long mqttReconnectInterval = 10000; // try every 10 sec

  // for saving engine hours
  unsigned long SAVE_INTERVAL = 60 * 1000UL;
  unsigned long lastSaveMillis = 0;

  bool btEnable = false;

// Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
uint32_t lastNtpSyncEpoch = 0;
bool ntpAvailable = false;
const unsigned long MAX_NTP_AGE_SEC = 24UL * 3600UL;  // 1 day


  // To print out on both Serial and bluetooth
void printAll(const char *fmt, ...) {
    char buf[128];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);

    Serial.print(buf);
    if (btEnable && SerialBT.hasClient()) {
        SerialBT.print(buf);
    }
}


void printBoth(const String& msg) {
  Serial.print(msg);
  #if defined(ESP32)
  SerialBT.print(msg);
  #endif
}

void printlnBoth(const String& msg) {
  Serial.println(msg);
  #if defined(ESP32)
  SerialBT.println(msg);
  #endif
}
// Overide printlnBoth
void printlnBoth(const char* msg) {
  Serial.println(msg);
  #if defined(ESP32)
  SerialBT.println(msg);
  #endif
}

void mqttHostPort(){
  char *colon = strchr(mqttServer, ':');
  if (colon != NULL) {
      // Found ':'
      size_t ipLen = colon - mqttServer;
      strncpy(mqttHost, mqttServer, ipLen);
      mqttHost[ipLen] = '\0';  // Null terminate

      mqttPort = atoi(colon + 1);
  } else {
      // No ':', use full as host
      strncpy(mqttHost, mqttServer, sizeof(mqttHost));
      mqttHost[sizeof(mqttHost) - 1] = '\0';
      mqttPort = 1883;  // default
  }
}

// WIFI settings
#define MAX_WIFI 5
struct WiFiEntry {
    char ssid[32];
    char pass[32];
};
WiFiEntry wifiList[MAX_WIFI];

void loadWiFiSettings() {
    prefs.begin("engine-hour", true);
    prefs.getBytes("wifiList", wifiList, sizeof(wifiList));
    prefs.end();
}
void saveWiFiSettings() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("wifiList", wifiList, sizeof(wifiList));
    prefs.end();
    Serial.println("💾 WiFi settings saved!");
}
void connectWiFi() {
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) == 0) continue;

        printAll("🔍 Trying WiFi: %s\n", wifiList[i].ssid);
        WiFi.begin(wifiList[i].ssid, wifiList[i].pass);

        if (WiFi.waitForConnectResult() == WL_CONNECTED) {
            printAll("✅ WiFi connected!");
            printAll("IP Address: ");
            printAll(WiFi.localIP().toString().c_str());
            return;
        } else {
            printAll("⚠️ Failed, trying next...");
        }
    }

    printAll("❌ No WiFi connected.");
}
void cmd_wifi(Stream &src) {
    if (WiFi.isConnected()) {
        src.printf("✅ Connected WiFi: %s (%s), IP: %s\n",
                   WiFi.SSID().c_str(),
                   WiFi.BSSIDstr().c_str(),
                   WiFi.localIP().toString().c_str());
    } else {
        src.println("❌ Not connected to any WiFi.");
    }

    src.println("📋 Saved WiFi list:");
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) > 0) {
            // src.printf("%d: %s / %s\n", i + 1, wifiList[i].ssid, wifiList[i].pass);
            src.printf("%d: %s / *********\n", i + 1, wifiList[i].ssid);
        }
    }
}
void cmd_addwifi(const char *ssid, const char *pass, Stream &src) {
    for (int i = 0; i < MAX_WIFI; i++) {
        if (strlen(wifiList[i].ssid) == 0) {
            strncpy(wifiList[i].ssid, ssid, sizeof(wifiList[i].ssid));
            strncpy(wifiList[i].pass, pass, sizeof(wifiList[i].pass));
            saveWiFiSettings();
            src.printf("✅ New WiFi added: %s / %s\n", ssid, pass);
            return;
        }
    }
    src.println("⚠️ WiFi list full. Delete old entry first.");
}
void cmd_removewifi(int index, Stream &src) {
    if (index < 1 || index > MAX_WIFI) {
        src.println("⚠️ Invalid index.");
        return;
    }

    index--;  // 1-based to 0-based
    memset(&wifiList[index], 0, sizeof(WiFiEntry));
    saveWiFiSettings();
    src.printf("✅ WiFi entry %d removed.\n", index + 1);
}
void cmd_clearwifi(Stream &src) {
    memset(wifiList, 0, sizeof(wifiList));
    saveWiFiSettings();
    src.println("✅ All WiFi entries cleared.");
}

// NTP server settings
#define MAX_NTP 5
char ntpList[MAX_NTP][32];

void loadNTPSettings() {
    prefs.begin("engine-hour", true);
    prefs.getBytes("ntpList", ntpList, sizeof(ntpList));
    prefs.end();
}

void saveNTPSettings() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("ntpList", ntpList, sizeof(ntpList));
    prefs.end();
    Serial.println("💾 NTP settings saved!");
}
void syncNTP(Stream &src) {
    // Ensure Wiifi is connected
    if (!WiFi.isConnected()) {
        src.println("❌ WiFi not connected. Cannot sync NTP.");
        return;
    }
    time_t now = time(nullptr);
    // If time already synced (example > 2024)
    if (now > 1700000000) {  // ~Jan 2024 timestamp
        src.println("⏳ Already synced — skip resync.");
        return;
    }

    struct tm timeinfo;
    bool synced = false;

    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) == 0) continue;

        configTime(3600 * 7, 0, ntpList[i]); // Example +7 timezone
        delay(2000);  // wait for NTP

        if (getLocalTime(&timeinfo)) {
            src.printf("✅ NTP sync OK: %s\n", ntpList[i]);
            synced = true;
            ntpSynced = true;
            break;
        } else {
            src.printf("⚠️ NTP failed: %s\n", ntpList[i]);
        }
    }

    // if (!synced) {
    //     src.println("❌ All NTP failed.");
    //     ntpSynced = false;
    // }

    // Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
    if (synced) {
        lastNtpSyncEpoch = time(nullptr);
        ntpAvailable = true;
        prefs.begin("ntp", false);
        prefs.putUInt("lastsync", lastNtpSyncEpoch);
        prefs.end();
        src.printf("✅ NTP sync successful. Last sync: %s\n", ctime(&lastNtpSyncEpoch));
        printAll("✅ NTP sync successful. Last sync: ");
    } else {
        ntpAvailable = false;
        printAll("❌ NTP sync failed.");
    }
    
}

void checkNtpStatus(Stream &out) {
  uint32_t nowEpoch = millis() / 1000; // uptime in seconds

  if (!ntpAvailable) {
    out.println("⚠️  NTP not available. Using internal time.");
  }

  if (lastNtpSyncEpoch == 0) {
    out.println("❌ No NTP sync history found.");
    return;
  }

  uint32_t timeSinceSync = nowEpoch - (lastNtpSyncEpoch % 0xFFFFFFFF);
  out.printf("🕒 Last NTP sync was %lu sec ago (%lu min)\n", timeSinceSync, timeSinceSync / 60);

  if (timeSinceSync < 3600) {
    out.println("✅ Time is accurate (synced < 1 hour ago).");
  } else if (timeSinceSync < MAX_NTP_AGE_SEC) {
    out.println("⚠️  Time may drift (last sync > 1 hour).");
  } else {
    out.println("❗ NTP sync too old (> 1 day) — risk of drift.");
  }
}


void cmd_ntp(Stream &src) {
    src.println("📋 Saved NTP list:");
    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) > 0) {
            src.printf("%d: %s\n", i + 1, ntpList[i]);
        }
    }
}

void cmd_addntp(const char *ntp, Stream &src) {
    for (int i = 0; i < MAX_NTP; i++) {
        if (strlen(ntpList[i]) == 0) {
            strncpy(ntpList[i], ntp, sizeof(ntpList[i]));
            saveNTPSettings();
            src.printf("✅ New NTP added: %s\n", ntp);

            // 👉 Optional: auto sync after adding
            syncNTP(src);

            return;
        }
    }
    src.println("⚠️ NTP list full. Delete old entry first.");
}
void cmd_removentp(int index, Stream &src) {
    if (index < 1 || index > MAX_NTP) {
        src.println("⚠️ Invalid index.");
        return;
    }

    index--;  // 1-based to 0-based
    memset(ntpList[index], 0, sizeof(ntpList[index]));
    saveNTPSettings();
    src.printf("✅ NTP entry %d removed.\n", index + 1);
}
void cmd_clearntp(Stream &src) {
    for (int i = 0; i < MAX_NTP; i++) {
        memset(ntpList[i], 0, sizeof(ntpList[i]));
    }
    saveNTPSettings();
    src.println("✅ All NTP entries cleared.");
}
// End NTP server settings

// MQTT settings
#define MAX_MQTT 3
struct MqttServerEntry {
    char host[48];    // IP or domain
    uint16_t port;
    char username[32];
    char password[32];
};


void loadMqttFromPrefs() {
    prefs.begin("mqtt", false);

    prefs.getString("host", mqttHost, sizeof(mqttHost));
    mqttPort = prefs.getUShort("port", 1883);
    prefs.getString("user", mqttUser, sizeof(mqttUser));
    prefs.getString("pass", mqttPass, sizeof(mqttPass));

    prefs.end();

    mqttClient.setServer(mqttHost, mqttPort);

    Serial.printf("📡 MQTT loaded: %s:%d User:%s\n", mqttHost, mqttPort, mqttUser);
}
void saveMqttToPrefs() {
    prefs.begin("mqtt", false);

    prefs.putString("host", mqttHost);
    prefs.putUShort("port", mqttPort);
    prefs.putString("user", mqttUser);
    prefs.putString("pass", mqttPass);

    prefs.end();

    Serial.println("💾 MQTT settings saved!");
}

void cmd_mqtt(Stream &src) {
    src.println("🔎 MQTT Settings:");
    src.printf("  Host: %s\n", mqttHost);
    src.printf("  Port: %u\n", mqttPort);
    src.printf("  User: %s\n", (strlen(mqttUser) > 0) ? mqttUser : "(none)");
    src.printf("  Pass: ***********\n");
    src.printf("  Status: %s\n", mqttClient.connected() ? "Connected" : "Not connected");
}

void cmd_addmqtt(char *args, Stream &src) {
  prefs.begin("mqtt", false);
  prefs.putString("host", mqttHost);
  prefs.putUShort("port", mqttPort);
  prefs.putString("user", mqttUser);
  prefs.putString("pass", mqttPass);
  prefs.end();

}

void ensureMqttConnected() {
    if (!WiFi.isConnected()) {
        return; // No WiFi — skip
    }

    if (!mqttClient.connected()) {
        unsigned long now = millis();
        if (now - mqttLastConnectAttempt >= mqttReconnectInterval) {
            printAll("🔄 Attempting MQTT connect to %s:%u ...\n", mqttHost, mqttPort);

            bool connected = false;
            if (strlen(mqttUser) > 0) {
                connected = mqttClient.connect(engine_name.c_str(), mqttUser, mqttPass);
            } else {
                connected = mqttClient.connect(engine_name.c_str());
            }

            if (connected) {
                printAll("✅ MQTT connected.");
            } else {
                printAll("⚠️ MQTT connect failed (state=%d)\n", mqttClient.state());
            }

            mqttLastConnectAttempt = now;
        }
    }

    // Must call loop always
    mqttClient.loop();
}

// End MQTT settings

void initializeConfig() {

  prefs.begin("engine-hour", true);  // read-only

  totalEngineHours = prefs.getFloat("totalHours", 0.0);
  totalEngineMinutes = prefs.getFloat("totalMins", 0.0);
  totalMoves = prefs.getULong("totalMoves", 0);



  // prefs.getBytes("ntpServer", ntpServer, sizeof(ntpServer));
  prefs.getBytes("engineName", engineName, sizeof(engineName));
  mqttHostPort(); // to split mqttServer into host and port

  prefs.end();
  Serial.printf("✅ Loaded Hours=%.2f Moves=%u Name=%s\n",
      totalEngineHours, totalMoves, engineName);

}

void saveConfig() {
    prefs.begin("engine-hour", false);
    prefs.putBytes("engineName", engineName, sizeof(engineName));
    prefs.putFloat("totalHours", totalEngineHours);
    prefs.putFloat("totalMins", totalEngineMinutes);
    // prefs.putBytes("mqttServer", mqttServer, sizeof(mqttServer));
    prefs.putULong("totalMoves", totalMoves);


    prefs.end();

    printAll("💾 Saved Hours=%.2f Moves=%u \n",
      totalEngineHours, totalMoves);
}




// Wifi indicator
void checkRunningAndDisplay() {
  // Clear the dot area first
  display.fillRect(0, 50, 10, 10, BLACK);

  if (engineRunning) {
    // Handle blinking
    if (millis() - lastRunningBlinkTime >= RUNNING_BLINK_INTERVAL) {
      runningBlinkState = !runningBlinkState;
      lastRunningBlinkTime = millis();
    }

    if (runningBlinkState) {
      display.fillCircle(4, 60, 2, WHITE);  // Draw blinking dot
    }
  }
  // else: don't show anything (area already cleared)
}

void showWifiStatus(bool connected) {
  static bool blinkState = false;
  static unsigned long lastBlink = 0;
  const int blinkInterval = 500;  // Blink every 500ms

  if (connected) {
    display.drawBitmap(0, 0, wifi_icon, 16, 16, WHITE);

  }
}

void showMQTTStatus(bool connected) {
  if (connected) {
      display.drawBitmap(20, 0, chain_icon, 10, 10, WHITE);  // Draw in bottom-left
  } 
}


void onBuzzer(bool on) {
  if (!on) {
    digitalWrite(BUZZER_PIN, HIGH);  // ensure buzzer is off
    return;
  }

  if (millis() - lastBuzzerToggle >= 1000) {
    buzzerLogicState = !buzzerLogicState;
    digitalWrite(BUZZER_PIN, buzzerLogicState ? HIGH : LOW);  // active LOW logic
    lastBuzzerToggle = millis();
  }
}



void connectWiFi(char* ssid, char* pass) {

  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, pass);
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
    delay(500);
    Serial.print(".");
  }

  // display.clearDisplay();

if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅ WiFi connected!");
  } else {
    Serial.println("\n❌ WiFi connection failed.");

  }

}


void loadSaveInterval() {

}

void showMessage(const String& message) {
  static bool visible = true;
  static unsigned long lastBlink = 0;
  const unsigned long blinkInterval = 500;  // milliseconds

  unsigned long now = millis();
  if (now - lastBlink >= blinkInterval) {
    visible = !visible;
    lastBlink = now;

    display.clearDisplay();
    display.fillScreen(SSD1306_WHITE);                 // White background

    if (visible) {
      display.setTextColor(SSD1306_BLACK);             // Black text
      display.setTextSize(2);

      int16_t x1, y1;
      uint16_t w, h;
      display.getTextBounds(message, 0, 0, &x1, &y1, &w, &h);

      int16_t x = (display.width() - w) / 2;
      int16_t y = (display.height() - h) / 2;
      display.setCursor(x, y);
      display.print(message);
    }

    display.display();
  }
}




void startEngine() {
  engineRunning = true;
  // engineStartTime = rtc.now().unixtime();
  lastSaveTime = millis();
  printlnBoth("✅ Engine running.");
}

void stopEngine() {
  if (engineRunning) {
    // updateEngineHours();
    // saveEngineHours();
    engineRunning = false;
    digitalWrite(LED_PIN, HIGH);
    printlnBoth("❌ Engine stop.");
  }
}

void sendToMqtt(const char* topic, const char* payload) {
    if (mqttClient.connected()) {
        mqttClient.publish(topic, payload);
        Serial.printf("✅ Published [%s]: %s\n", topic, payload);
    } else {
        Serial.println("⚠️ MQTT not connected.");
    }
}


void publish_data(){
      // reconnectMQTT(); // Reconnect MQTT if needed and see if any MQTT server is connected
      printAll("📡 Sending to all MQTT servers\n");
          // Send Engine Total Hour
        char payload_totalhour[16];
        dtostrf(totalEngineMinutes/60.0, 1, 2, payload_totalhour);  // width=1, precision=2
        String topic_hour = "engine/" + engine_name + "/hour";
        sendToMqtt(topic_hour.c_str(),payload_totalhour);

        // Send Engine Total Move
        char payload_totalmove[12]; // Enough for int range
        itoa(totalMoves, payload_totalmove, 10);  // base 10
        String topic_move = "engine/" + engine_name + "/move";
        sendToMqtt(topic_move.c_str(),payload_totalmove);

        // Send Engine malfunction
        String topic_malfunction = "engine/" + engine_name + "/malfunction";
        char engineCheckStr[10];  // Make sure the buffer is big enough
        itoa(engine_check, engineCheckStr, 10);  // 10 means base 10 (decimal)
        sendToMqtt(topic_malfunction.c_str(),engineCheckStr);

        printAll("✅ Done sending to all MQTT.\n");
}

void showEngineFaultScreen() {
  display.clearDisplay();

  // Draw engine icon in center
  int iconX = 0;//(SCREEN_WIDTH - 16) / 2;
  int iconY = 8;
  display.drawBitmap(iconX, iconY, image_check_engine, 128, 64, WHITE);

  display.display();
}

void showOilChangeScreen() {
  display.clearDisplay();
  // Draw engine icon in center
  int iconX = 0;//(SCREEN_WIDTH - 16) / 2;
  int iconY = 8;
  // display.drawBitmap(iconX, iconY, image_battery, 128, 64, WHITE);
  display.drawBitmap(iconX, iconY, image_check_engine, 128, 64, WHITE);

  display.display();
}

void showAlertScreen(const uint8_t* image, const char* message) {
  display.clearDisplay();

  // Draw image in center
  int iconX = 0;//(SCREEN_WIDTH - 64) / 2;  // Adjust based on image width (e.g., 64)
  int iconY = 0;                        // Top-aligned
  display.drawBitmap(iconX, iconY, image, 128, 64, WHITE);

  // Draw bottom-centered message
  display.setTextSize(1);
  display.setTextColor(WHITE);

  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(message, 0, 0, &x1, &y1, &w, &h);
  int textX = (SCREEN_WIDTH - w) / 2;
  int textY = SCREEN_HEIGHT - h + 1;  // A bit above the bottom
  display.setCursor(textX, textY);
  display.print(message);

  display.display();

}

void updateDisplay(bool showNormalDisplay) {
    
    if (showNormalDisplay){
    display.clearDisplay();

    // Line 1: "Running" (if running) and engine name
    display.setTextSize(1);

    // char timeStr[9];
    // snprintf(timeStr, sizeof(timeStr), "%02d:%02d:%02d", now.hour(), now.minute(), now.second());
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        currentTime.year   = timeinfo.tm_year + 1900;
        currentTime.month  = timeinfo.tm_mon + 1;
        currentTime.day    = timeinfo.tm_mday;
        currentTime.hour   = timeinfo.tm_hour;
        currentTime.minute = timeinfo.tm_min;
        currentTime.second = timeinfo.tm_sec;
      }
    display.setCursor(35, 0);  // adjust X for alignment if needed

    char buf[9];
    sprintf(buf, "%d:%02d:%02d", currentTime.hour, currentTime.minute, currentTime.second);
    display.print(buf);
    
    display.setCursor(96, 0);
    display.print(engineName);
  
    // Line 2: Big Total Hour in center
    display.setTextSize(2);
    char mainStr[12];
    int16_t x1, y1; uint16_t w, h;

      sprintf(mainStr, "%010.2f", totalEngineMinutes/60.0);

    display.getTextBounds(mainStr, 0, 0, &x1, &y1, &w, &h);
    display.setCursor(SCREEN_WIDTH - w, 25);
    display.print(mainStr);

    // Show Total move
    char moveStr[12];
    int16_t xm1, ym1; uint16_t wm, hm;
    sprintf(moveStr, "%10d", totalMoves); // pad total moves right-aligned

    display.getTextBounds(mainStr, 0, 0, &xm1, &ym1, &wm, &hm);
    display.setCursor(SCREEN_WIDTH - w, 48);
    display.print(moveStr);
  

      // checkWiFiStatusAndDisplay();
      checkRunningAndDisplay(); //Show blinking running
      #if defined(ESP32)
        showWifiStatus(WiFi.isConnected()); //show Wifi status
      #elif defined(ESP8266)
        showWifiStatus(WiFi.status() == WL_CONNECTED); //show Wifi status
      #endif

        // Show MQTT status
        if (mqttClient.connected()) {
          showMQTTStatus(true);
        } else {
          showMQTTStatus(false);
        }

        // Show engine fault if any
        if (engine_check) {
          showEngineFaultScreen();
        } else {
          display.display();
        }
  }
}

void blinkLED() {
  static unsigned long lastBlink = 0;
  static bool ledState = false;
  if (millis() - lastBlink >= 500) {
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState ? LOW : HIGH);
    lastBlink = millis();
  }
}



float readFloat(int addr) {
  float val;
  // EEPROM.get(addr, val);
  return (isnan(val) || val < 0) ? 0.0 : val;
}



void writeName(String name, Stream &src) {
  engine_name = name;
  name.toCharArray(engineName, 32);
  src.println("✅ change engine name successful.");
  saveConfig();  // Save to preferences
}



void writeShiftName(int addr, String name) {
  // for (int i = 0; i < MAX_NAME_LENGTH; i++) EEPROM.write(addr + i, name[i]);
  // EEPROM.commit();
}



void set_time(String input) {

  Serial.println("Time set.");
}

void show_time(Stream &out) {

   struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        currentTime.year   = timeinfo.tm_year + 1900;
        currentTime.month  = timeinfo.tm_mon + 1;
        currentTime.day    = timeinfo.tm_mday;
        currentTime.hour   = timeinfo.tm_hour;
        currentTime.minute = timeinfo.tm_min;
        currentTime.second = timeinfo.tm_sec;

        out.printf("Current time: %04d/%02d/%02d %02d:%02d:%02d\n",
            currentTime.year, currentTime.month, currentTime.day,
            currentTime.hour, currentTime.minute, currentTime.second);
    } else {
        out.println("Failed to obtain time.");
    }
}

void saveMovesToEEPROM() {

}



void handleSerialCommand(String cmd, Stream &src) {
  if (cmd == "hour") src.println(totalEngineMinutes/60.0, 2);
  else if (cmd.startsWith("sethour")) {
      totalEngineHours = cmd.substring(8).toFloat();
      totalEngineMinutes = totalEngineHours * 60;
      src.print("✅ Set hour: ");
      src.println(totalEngineMinutes / 60.0, 2);
  }
  else if (cmd == "name") src.println(engineName);
  else if (cmd.startsWith("setname")) writeName(cmd.substring(8, 18),src);
  else if (cmd == "time") show_time(src);
  else if (cmd == "interval") {
    src.printf("Current save interval: %lu seconds\n", SAVE_INTERVAL / 1000UL);
  }
  else if (cmd.startsWith("setinterval ")) {
    unsigned long sec = cmd.substring(12).toInt();
    if (sec > 0 && sec <= 86400) {
      // SAVE_INTERVAL = sec * 1000UL;
      // EEPROM.put(EEPROM_ADDR_INTERVAL, sec);
      // EEPROM.commit();
      src.printf("✅ Save interval set to: %lu seconds\n", sec);
    } else {
      src.println("Invalid value. Use 1–86400 seconds.");
    }
  }
  else if (cmd == "wifi") {
    cmd_wifi(src); // Show WiFi status
  } //end cmd.startsWith("wifi")
  else if (cmd == "wifi list") {
    src.println("Scanning Wi-Fi networks...");
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    delay(100);
    int n = WiFi.scanNetworks();
    if (n == 0) {
      src.println("No networks found.");
    } else {
      src.printf("%d networks found:\n", n);
      for (int i = 0; i < n; ++i) {
        src.printf("%d: %s (%d dBm) %s\n", i + 1,
          WiFi.SSID(i).c_str(),
          WiFi.RSSI(i),
          #if defined(ESP32)
          (WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? "Open" : "Secured");
          #elif defined(ESP8266)
          (WiFi.encryptionType(i) == ENC_TYPE_NONE) ? "Open" : "Secured");
          #endif
      }
    }
  } else if ( cmd.startsWith("addwifi" )){
    int firstSpace = cmd.indexOf(' ');
    int secondSpace = cmd.indexOf(' ', firstSpace + 1);
    if (firstSpace != -1 && secondSpace != -1) {
      String ssid_str = cmd.substring(firstSpace + 1, secondSpace);
      String pass_str = cmd.substring(secondSpace + 1);
      char ssid[32], pass[32];
      ssid_str.toCharArray(ssid, 32);
      pass_str.toCharArray(pass, 32);
      cmd_addwifi( ssid, pass,src);
      connectWiFi();
    }else {
      src.println("Usage: addwifi SSID PASSWORD");
    }
  } else if ( cmd.startsWith("removewifi" )){
    cmd_removewifi(cmd.substring(11).toInt(), src);
  } else if ( cmd.startsWith("clearwifi" )){
    cmd_clearwifi(src);
  }
  // MOve
  else if (cmd == "move") {
    src.printf("%d", totalMoves);
  } else if (cmd.startsWith("setmove ")) {
    int newValue = cmd.substring(8).toInt();
    totalMoves = newValue;
    saveMovesToEEPROM();
    src.println("✅ Total move updated.");
  } else if (cmd == "mqtt") {
    cmd_mqtt(src); // Show MQTT status
  }
  else if (cmd.startsWith("addmqtt ")) {
    char argsChr[128];
    cmd.substring(8).toCharArray(argsChr, sizeof(argsChr));

    char host[64], user[32], pass[32];
    int port = 1883;

    int params = sscanf(argsChr, "%63[^:]:%d %31s %31s", host, &port, user, pass);

    if (params >= 2) {
        strcpy(mqttHost, host);
        mqttPort = port;

        if (params >= 4) {
            strcpy(mqttUser, user);
            strcpy(mqttPass, pass);
        } else {
            mqttUser[0] = 0;
            mqttPass[0] = 0;
        }

        mqttClient.setServer(mqttHost, mqttPort);

        // Save
        prefs.begin("mqtt", false);
        prefs.putString("host", mqttHost);
        prefs.putUShort("port", mqttPort);
        prefs.putString("user", mqttUser);
        prefs.putString("pass", mqttPass);
        prefs.end();

        Serial.printf("✅ MQTT saved: %s:%d User:%s\n", mqttHost, mqttPort, mqttUser);
    } else {
        Serial.println("⚠️ Invalid format! Use: addmqtt host:port [user] [pass]");
    }
} else if (cmd == "clearmqtt") {
    mqttHost[0] = 0;
    mqttPort = 1883;
    mqttUser[0] = 0;
    mqttPass[0] = 0;

    prefs.begin("mqtt", false);
    prefs.clear();
    prefs.end();

    mqttClient.disconnect();

    Serial.println("✅ MQTT settings cleared.");
} else if (cmd == "testmqtt") {
    if (mqttClient.connected()) {
        sendToMqtt("test/topic", "Hello from device!");
    } else {
        Serial.println("⚠️ MQTT not connected.");
    }
} else if (cmd == "mqttinterval") {
    src.print("MQTT Interval (sec): ");
    src.println(mqttSendInterval/1000);
  } else if (cmd.startsWith("setmqttinterval ")) {
    String param = cmd.substring(16);
    mqttSendInterval = param.toInt() * 1000UL;
    src.print("✅ MQTT Interval set to ");
    src.print(mqttSendInterval/1000);
    src.println(" sec");
  } else if (cmd.startsWith("pm ")){
    isPm = false;
    alertMsg = "";
    String msg = cmd.substring(3);
    if (msg.length() > 1){
        isPm = true;
        alertMsg = msg;
        src.println("✅ set PM message successful.");
    } else {
        src.println("✅ reset PM message successful.");
    }
  } else if (cmd == "moveminactive") { //MIn move active
    src.print("🕒 Move min active duration: ");
    src.print(minActiveMs/1000);
    src.println(" s");
  }
  else if (cmd.startsWith("setmoveminactive")) {
    int spaceIndex = cmd.indexOf(' ');
    if (spaceIndex != -1) {
      String valueStr = cmd.substring(spaceIndex + 1);
      int newMs = valueStr.toInt();

      minActiveMs = newMs*1000;
      // saveMinActiveMs();
      src.print("✅ Set move min active to ");
      src.print(minActiveMs/1000);
      src.println(" s");

    }
} else if (cmd == "ntp") {
  cmd_ntp(src); // Show NTP status
} else if (cmd.startsWith("addntp ")) {
    int firstSpace = cmd.indexOf(' ');
    if (firstSpace != -1) {
      char ntpServer_[32];
      String ntpServerStr = cmd.substring(firstSpace + 1);
      ntpServerStr.toCharArray(ntpServer_, 32);
      cmd_addntp(ntpServer_, src);
    } else {
      src.println("Usage: addntp <NTP_SERVER>");
    }
  } else if (cmd.startsWith("removentp ")) {
    int index = cmd.substring(10).toInt();
    if (index >= 0 && index < MAX_NTP ) {
      cmd_removentp(index, src);
    } else {
      src.println("Invalid index. Use 0 to 4.");
    }
  } else if (cmd == "ntpstatus") {
    checkNtpStatus(src);
  } else if (cmd == "help") {
    src.println("Available commands:");
    src.println("1 - Start engine");
    // src.println("0 - Stop engine");
    src.println("hour - Show total engine hours");
    src.println("sethour <value> - Set total engine hours");
    src.println("name - Show engine name");
    src.println("setname <name> - Set engine name");
    src.println("time - Show current time");
    src.println("interval - Show save interval in seconds");
    src.println("setinterval <seconds> - Set save interval in seconds (1-86400)");
    src.println("wifi - Show WiFi status");
    src.println("wifi list - List available WiFi networks");
    src.println("addwifi <SSID> <PASSWORD> - Add a new WiFi network");
    src.println("removewifi <index> - Remove a WiFi network by index");
    src.println("clearwifi - Clear all saved WiFi networks");
    src.println("move - Show total moves count");
    src.println("setmove <count> - Set total moves count");
    src.println("mqtt - Show MQTT server and connection status");
    src.println("setmqtt <server:port> - Set MQTT server and port");
    src.println("mqttinterval - Show MQTT send interval in seconds");
    src.println("setmqttinterval <seconds> - Set MQTT send interval in seconds (default 10)");
    src.println("testmqtt - Test MQTT connection with current settings");
    src.println("pm <message> - Set PM message or reset it if empty");
    
}
}








void setup(){
  Wire.begin(OLED_SDA, OLED_SCL);
  // Initialize the display
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("SSD1306 not found");
    while (true);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  showAlertScreen(image_company,"LOADING.....");
  display.display();

  Serial.begin(115200);

    pinMode(LED_PIN, OUTPUT);
    pinMode(ENGINE_INPUT_PIN, INPUT_PULLUP); //for Hour

    #ifndef INPUT_PULLDOWN
    #define INPUT_PULLDOWN INPUT_PULLDOWN_16
    #endif
    pinMode(MOVE_INPUT_PIN, INPUT_PULLDOWN); //for move
    pinMode(CHECK_ENGINE_INPUT_PIN,INPUT_PULLDOWN);//for Display mode UP=Hour,DOWN=Move
    pinMode(BUZZER_PIN, OUTPUT);
    digitalWrite(BUZZER_PIN, HIGH);  // For active-LOW buzzer (OFF)
   // Initialize EEPROM 
    initializeConfig();

    // connectWiFi(wifiSSID, wifiPASS);
    loadWiFiSettings();
    loadNTPSettings();
    // loadMqttList();

    connectWiFi();
    // reconnectMQTT();
    loadMqttFromPrefs();

    // Added on June 25,2025 -- To support NTP in-case of no wifi (prolonged power outage)
    prefs.begin("ntp", true);
    lastNtpSyncEpoch = prefs.getUInt("lastsync", 0);
    prefs.end();

    engine_name = String(engineName);
    if (engine_name.length() == 0) {
      engine_name = "Engine1"; // Default name
      // writeName(engine_name, Serial);
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    // For Enable Bluetooth
    
    #if defined(ESP32)
      btEnable = SerialBT.begin(engine_name);
      SerialBT.println("Bluetooth is ready");
    #endif

    Serial.println("Bluetooth started! Waiting for connections...");

    // mqttClient.setServer(mqttHost, mqttPort);

    if (WiFi.status() == WL_CONNECTED) {
      // WiFi is connected, synchronize time
      // synchroniseWith_NTP_Time(Serial);   
      // publish_data();
      syncNTP(Serial);
    }

}



// Counting Move
void checkMoveInput() {
  bool reading = digitalRead(MOVE_INPUT_PIN);

  // Debounce handling
  if (reading != lastMoveButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > DEBOUNCE_DELAY_MS) {
    // If stable reading and changed
    if (reading != moveButtonState) {
      moveButtonState = reading;

      if (moveButtonState == HIGH) {
        highStartTime = millis(); // Start timing the HIGH state
        highStable = true;
        isLifting = true;         // ✅ Set AFTER debounce confirmed HIGH
      }
      else if (moveButtonState == LOW && highStable) {
        // Check how long it stayed HIGH
        if (millis() - highStartTime >= minActiveMs) {
          // Check if engine running then increase moving
          printlnBoth("✅ Move On.");
          if (engineRunning) {
            totalMoves++;

          }//end check engingRunning

          isLifting = false;

        }
        highStable = false;  // Reset
        isLifting = false;        // ✅ End lifting after LOW
      }
    }
  }

  lastMoveButtonState = reading;
}
// End Counting Move

void resyncNTP_period() {
  if (WiFi.status() == WL_CONNECTED) {
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        currentTime.year   = timeinfo.tm_year + 1900;
        currentTime.month  = timeinfo.tm_mon + 1;
        currentTime.day    = timeinfo.tm_mday;
        currentTime.hour   = timeinfo.tm_hour;
        currentTime.minute = timeinfo.tm_min;
        currentTime.second = timeinfo.tm_sec;

        // Morning resync at 07:30
        if (currentTime.hour == 8 && currentTime.minute == 05) {
            if (!resyncDoneMorning) {
                Serial.println("⏰ Morning NTP Resync...");
                // synchroniseWith_NTP_Time(Serial);
                syncNTP(Serial);
                resyncDoneMorning = true;
            }
        } else {
            resyncDoneMorning = false; // reset flag after minute passes
        }

        // Evening resync at 19:30 (7:30 PM)
        if (currentTime.hour == 20 && currentTime.minute == 05) {
            if (!resyncDoneEvening) {
                Serial.println("⏰ Evening NTP Resync...");
                // synchroniseWith_NTP_Time(Serial);
                syncNTP(Serial);
                resyncDoneEvening = true;
            }
        } else {
            resyncDoneEvening = false;
        }
    }
  

  }
}

void loop(){
      unsigned long now = millis();
    if (now - lastSaveMillis > SAVE_INTERVAL) {
        lastSaveMillis = now;
        saveConfig();
    }

          // Watchdog: check every 30s
      if (millis() - lastNtpAttempt > 30000) {
        lastNtpAttempt = millis();

        if (WiFi.status() != WL_CONNECTED) {
          printAll("🔄 WiFi disconnected — trying to reconnect...");
          // WiFi.begin(ssid, pass);
          connectWiFi();
        } else if (!ntpSynced) {
          printAll("🔄 Trying NTP sync again...");
          // synchroniseWith_NTP_Time(Serial);
          syncNTP(Serial);
        }
      }

    if (Serial.available()) {
      String cmd = Serial.readStringUntil('\n');
      cmd.trim();
      handleSerialCommand(cmd,Serial);
    }
    // To support Bluetooth
    #if defined(ESP32)
    if (SerialBT.available()) {
      String cmd = SerialBT.readStringUntil('\n');
      cmd.trim();
      handleSerialCommand(cmd,SerialBT);
    }
    #endif

    // for check input
    // If fou d any problem , Display will change to Alert mode
    if(isCheckEngine || isPm || isChargeFail || isLifting){
      alertDisplay = true;
      if(isCheckEngine || isPm) onBuzzer(true);
    }else{
      alertDisplay = false;
      onBuzzer(false);
    }

    if (isCheckEngine){
      showAlertScreen(image_check_engine,"SYSTEM FAULT!");
    }
    if (isPm){
      showAlertScreen(image_oil_change,alertMsg.c_str());
    }

    // Handle Move count
    checkMoveInput();
    if (isLifting){
      showAlertScreen(image_move_up,"LIFTING");
    }
    
    if (engineRunning && millis() - lastMinuteUpdate >= 60000) {
      totalEngineMinutes++;
      totalEngineHours = totalEngineMinutes /60.0;
      lastMinuteUpdate = millis();  // Reset timer
    }

    bool engineSignal = digitalRead(ENGINE_INPUT_PIN) == LOW;
    if (engineSignal && !engineRunning) startEngine();
    else if (!engineSignal && engineRunning) {
      stopEngine();
    }
    // End input

    // send MQTT data every mqttSendInterval
    if (millis() - lastMQTTSendTime >= mqttSendInterval) {  
      if (WiFi.status() == WL_CONNECTED) {
        // Send Engine Total Hour
        ensureMqttConnected();
        publish_data();
      } else {
        // Optional: Retry MQTT connection here (or just skip)
        printAll("MQTT/WiFi unavailable. Skipping send.");
      }
      lastMQTTSendTime = millis();
    }
    // End send MQTT data

    // if (WiFi.isConnected()) {
    //   if (!mqttClient.connected()) {
    //       if (strlen(mqttUser) > 0) {
    //           mqttClient.connect("client_id", mqttUser, mqttPass);
    //       } else {
    //           mqttClient.connect("client_id");
    //       }

    //       // if (mqttClient.connected()) {
    //       //     Serial.println("✅ MQTT connected!");
    //       // } else {
    //       //     Serial.println("⚠️ MQTT connect failed.");
    //       // }
    //   }

    //     mqttClient.loop();
    // }

    ensureMqttConnected();

    updateDisplay(!alertDisplay);
    delay(100); // Add a small delay to avoid busy loop

}

  

